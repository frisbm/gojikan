// Package gojikan provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package gojikan

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"github.com/oapi-codegen/runtime"
)

// Defines values for AnimeRating.
const (
	AnimeRatingGAllAges             AnimeRating = "G - All Ages"
	AnimeRatingPG13Teens13OrOlder   AnimeRating = "PG-13 - Teens 13 or older"
	AnimeRatingPGChildren           AnimeRating = "PG - Children"
	AnimeRatingR17ViolenceProfanity AnimeRating = "R - 17+ (violence & profanity)"
	AnimeRatingRMildNudity          AnimeRating = "R+ - Mild Nudity"
	AnimeRatingRxHentai             AnimeRating = "Rx - Hentai"
)

// Defines values for AnimeSeason.
const (
	AnimeSeasonFall   AnimeSeason = "fall"
	AnimeSeasonSpring AnimeSeason = "spring"
	AnimeSeasonSummer AnimeSeason = "summer"
	AnimeSeasonWinter AnimeSeason = "winter"
)

// Defines values for AnimeStatus.
const (
	AnimeStatusCurrentlyAiring AnimeStatus = "Currently Airing"
	AnimeStatusFinishedAiring  AnimeStatus = "Finished Airing"
	AnimeStatusNotYetAired     AnimeStatus = "Not yet aired"
)

// Defines values for AnimeType.
const (
	AnimeTypeMovie   AnimeType = "Movie"
	AnimeTypeMusic   AnimeType = "Music"
	AnimeTypeONA     AnimeType = "ONA"
	AnimeTypeOVA     AnimeType = "OVA"
	AnimeTypeSpecial AnimeType = "Special"
	AnimeTypeTV      AnimeType = "TV"
)

// Defines values for AnimeFullRating.
const (
	AnimeFullRatingGAllAges             AnimeFullRating = "G - All Ages"
	AnimeFullRatingPG13Teens13OrOlder   AnimeFullRating = "PG-13 - Teens 13 or older"
	AnimeFullRatingPGChildren           AnimeFullRating = "PG - Children"
	AnimeFullRatingR17ViolenceProfanity AnimeFullRating = "R - 17+ (violence & profanity)"
	AnimeFullRatingRMildNudity          AnimeFullRating = "R+ - Mild Nudity"
	AnimeFullRatingRxHentai             AnimeFullRating = "Rx - Hentai"
)

// Defines values for AnimeFullSeason.
const (
	AnimeFullSeasonFall   AnimeFullSeason = "fall"
	AnimeFullSeasonSpring AnimeFullSeason = "spring"
	AnimeFullSeasonSummer AnimeFullSeason = "summer"
	AnimeFullSeasonWinter AnimeFullSeason = "winter"
)

// Defines values for AnimeFullStatus.
const (
	AnimeFullStatusCurrentlyAiring AnimeFullStatus = "Currently Airing"
	AnimeFullStatusFinishedAiring  AnimeFullStatus = "Finished Airing"
	AnimeFullStatusNotYetAired     AnimeFullStatus = "Not yet aired"
)

// Defines values for AnimeFullType.
const (
	AnimeFullTypeMovie   AnimeFullType = "Movie"
	AnimeFullTypeMusic   AnimeFullType = "Music"
	AnimeFullTypeONA     AnimeFullType = "ONA"
	AnimeFullTypeOVA     AnimeFullType = "OVA"
	AnimeFullTypeSpecial AnimeFullType = "Special"
	AnimeFullTypeTV      AnimeFullType = "TV"
)

// Defines values for AnimeSearchQueryOrderby.
const (
	AnimeSearchQueryOrderbyEndDate    AnimeSearchQueryOrderby = "end_date"
	AnimeSearchQueryOrderbyEpisodes   AnimeSearchQueryOrderby = "episodes"
	AnimeSearchQueryOrderbyFavorites  AnimeSearchQueryOrderby = "favorites"
	AnimeSearchQueryOrderbyMalId      AnimeSearchQueryOrderby = "mal_id"
	AnimeSearchQueryOrderbyMembers    AnimeSearchQueryOrderby = "members"
	AnimeSearchQueryOrderbyPopularity AnimeSearchQueryOrderby = "popularity"
	AnimeSearchQueryOrderbyRank       AnimeSearchQueryOrderby = "rank"
	AnimeSearchQueryOrderbyScore      AnimeSearchQueryOrderby = "score"
	AnimeSearchQueryOrderbyScoredBy   AnimeSearchQueryOrderby = "scored_by"
	AnimeSearchQueryOrderbyStartDate  AnimeSearchQueryOrderby = "start_date"
	AnimeSearchQueryOrderbyTitle      AnimeSearchQueryOrderby = "title"
)

// Defines values for AnimeSearchQueryRating.
const (
	AnimeSearchQueryRatingG    AnimeSearchQueryRating = "g"
	AnimeSearchQueryRatingPg   AnimeSearchQueryRating = "pg"
	AnimeSearchQueryRatingPg13 AnimeSearchQueryRating = "pg13"
	AnimeSearchQueryRatingR    AnimeSearchQueryRating = "r"
	AnimeSearchQueryRatingR17  AnimeSearchQueryRating = "r17"
	AnimeSearchQueryRatingRx   AnimeSearchQueryRating = "rx"
)

// Defines values for AnimeSearchQueryStatus.
const (
	AnimeSearchQueryStatusAiring   AnimeSearchQueryStatus = "airing"
	AnimeSearchQueryStatusComplete AnimeSearchQueryStatus = "complete"
	AnimeSearchQueryStatusUpcoming AnimeSearchQueryStatus = "upcoming"
)

// Defines values for AnimeSearchQueryType.
const (
	AnimeSearchQueryTypeCm        AnimeSearchQueryType = "cm"
	AnimeSearchQueryTypeMovie     AnimeSearchQueryType = "movie"
	AnimeSearchQueryTypeMusic     AnimeSearchQueryType = "music"
	AnimeSearchQueryTypeOna       AnimeSearchQueryType = "ona"
	AnimeSearchQueryTypeOva       AnimeSearchQueryType = "ova"
	AnimeSearchQueryTypePv        AnimeSearchQueryType = "pv"
	AnimeSearchQueryTypeSpecial   AnimeSearchQueryType = "special"
	AnimeSearchQueryTypeTv        AnimeSearchQueryType = "tv"
	AnimeSearchQueryTypeTvSpecial AnimeSearchQueryType = "tv_special"
)

// Defines values for CharactersSearchQueryOrderby.
const (
	CharactersSearchQueryOrderbyFavorites CharactersSearchQueryOrderby = "favorites"
	CharactersSearchQueryOrderbyMalId     CharactersSearchQueryOrderby = "mal_id"
	CharactersSearchQueryOrderbyName      CharactersSearchQueryOrderby = "name"
)

// Defines values for ClubAccess.
const (
	ClubAccessPrivate ClubAccess = "private"
	ClubAccessPublic  ClubAccess = "public"
	ClubAccessSecret  ClubAccess = "secret"
)

// Defines values for ClubCategory.
const (
	ClubCategoryActorsArtists       ClubCategory = "actors & artists"
	ClubCategoryAnime               ClubCategory = "anime"
	ClubCategoryCharacters          ClubCategory = "characters"
	ClubCategoryCitiesNeighborhoods ClubCategory = "cities & neighborhoods"
	ClubCategoryCompanies           ClubCategory = "companies"
	ClubCategoryConventions         ClubCategory = "conventions"
	ClubCategoryGames               ClubCategory = "games"
	ClubCategoryJapan               ClubCategory = "japan"
	ClubCategoryManga               ClubCategory = "manga"
	ClubCategoryMusic               ClubCategory = "music"
	ClubCategoryOthers              ClubCategory = "others"
	ClubCategorySchools             ClubCategory = "schools"
)

// Defines values for ClubSearchQueryCategory.
const (
	ClubSearchQueryCategoryActorsAndArtists       ClubSearchQueryCategory = "actors_and_artists"
	ClubSearchQueryCategoryAnime                  ClubSearchQueryCategory = "anime"
	ClubSearchQueryCategoryCharacters             ClubSearchQueryCategory = "characters"
	ClubSearchQueryCategoryCitiesAndNeighborhoods ClubSearchQueryCategory = "cities_and_neighborhoods"
	ClubSearchQueryCategoryCompanies              ClubSearchQueryCategory = "companies"
	ClubSearchQueryCategoryConventions            ClubSearchQueryCategory = "conventions"
	ClubSearchQueryCategoryGames                  ClubSearchQueryCategory = "games"
	ClubSearchQueryCategoryJapan                  ClubSearchQueryCategory = "japan"
	ClubSearchQueryCategoryManga                  ClubSearchQueryCategory = "manga"
	ClubSearchQueryCategoryMusic                  ClubSearchQueryCategory = "music"
	ClubSearchQueryCategoryOther                  ClubSearchQueryCategory = "other"
	ClubSearchQueryCategorySchools                ClubSearchQueryCategory = "schools"
)

// Defines values for ClubSearchQueryOrderby.
const (
	ClubSearchQueryOrderbyCreated      ClubSearchQueryOrderby = "created"
	ClubSearchQueryOrderbyMalId        ClubSearchQueryOrderby = "mal_id"
	ClubSearchQueryOrderbyMembersCount ClubSearchQueryOrderby = "members_count"
	ClubSearchQueryOrderbyName         ClubSearchQueryOrderby = "name"
)

// Defines values for ClubSearchQueryType.
const (
	ClubSearchQueryTypePrivate ClubSearchQueryType = "private"
	ClubSearchQueryTypePublic  ClubSearchQueryType = "public"
	ClubSearchQueryTypeSecret  ClubSearchQueryType = "secret"
)

// Defines values for GenreQueryFilter.
const (
	GenreQueryFilterDemographics   GenreQueryFilter = "demographics"
	GenreQueryFilterExplicitGenres GenreQueryFilter = "explicit_genres"
	GenreQueryFilterGenres         GenreQueryFilter = "genres"
	GenreQueryFilterThemes         GenreQueryFilter = "themes"
)

// Defines values for MagazinesQueryOrderby.
const (
	MagazinesQueryOrderbyCount MagazinesQueryOrderby = "count"
	MagazinesQueryOrderbyMalId MagazinesQueryOrderby = "mal_id"
	MagazinesQueryOrderbyName  MagazinesQueryOrderby = "name"
)

// Defines values for MangaStatus.
const (
	MangaStatusDiscontinued    MangaStatus = "Discontinued"
	MangaStatusFinished        MangaStatus = "Finished"
	MangaStatusNotYetPublished MangaStatus = "Not yet published"
	MangaStatusOnHiatus        MangaStatus = "On Hiatus"
	MangaStatusPublishing      MangaStatus = "Publishing"
)

// Defines values for MangaType.
const (
	MangaTypeDoujinshi  MangaType = "Doujinshi"
	MangaTypeLightNovel MangaType = "Light Novel"
	MangaTypeManga      MangaType = "Manga"
	MangaTypeManhua     MangaType = "Manhua"
	MangaTypeManhwa     MangaType = "Manhwa"
	MangaTypeNovel      MangaType = "Novel"
	MangaTypeOEL        MangaType = "OEL"
	MangaTypeOneShot    MangaType = "One-shot"
)

// Defines values for MangaFullStatus.
const (
	MangaFullStatusDiscontinued    MangaFullStatus = "Discontinued"
	MangaFullStatusFinished        MangaFullStatus = "Finished"
	MangaFullStatusNotYetPublished MangaFullStatus = "Not yet published"
	MangaFullStatusOnHiatus        MangaFullStatus = "On Hiatus"
	MangaFullStatusPublishing      MangaFullStatus = "Publishing"
)

// Defines values for MangaFullType.
const (
	MangaFullTypeDoujinshi  MangaFullType = "Doujinshi"
	MangaFullTypeLightNovel MangaFullType = "Light Novel"
	MangaFullTypeManga      MangaFullType = "Manga"
	MangaFullTypeManhua     MangaFullType = "Manhua"
	MangaFullTypeManhwa     MangaFullType = "Manhwa"
	MangaFullTypeNovel      MangaFullType = "Novel"
	MangaFullTypeOEL        MangaFullType = "OEL"
	MangaFullTypeOneShot    MangaFullType = "One-shot"
)

// Defines values for MangaSearchQueryOrderby.
const (
	MangaSearchQueryOrderbyChapters   MangaSearchQueryOrderby = "chapters"
	MangaSearchQueryOrderbyEndDate    MangaSearchQueryOrderby = "end_date"
	MangaSearchQueryOrderbyFavorites  MangaSearchQueryOrderby = "favorites"
	MangaSearchQueryOrderbyMalId      MangaSearchQueryOrderby = "mal_id"
	MangaSearchQueryOrderbyMembers    MangaSearchQueryOrderby = "members"
	MangaSearchQueryOrderbyPopularity MangaSearchQueryOrderby = "popularity"
	MangaSearchQueryOrderbyRank       MangaSearchQueryOrderby = "rank"
	MangaSearchQueryOrderbyScore      MangaSearchQueryOrderby = "score"
	MangaSearchQueryOrderbyScoredBy   MangaSearchQueryOrderby = "scored_by"
	MangaSearchQueryOrderbyStartDate  MangaSearchQueryOrderby = "start_date"
	MangaSearchQueryOrderbyTitle      MangaSearchQueryOrderby = "title"
	MangaSearchQueryOrderbyVolumes    MangaSearchQueryOrderby = "volumes"
)

// Defines values for MangaSearchQueryStatus.
const (
	MangaSearchQueryStatusComplete     MangaSearchQueryStatus = "complete"
	MangaSearchQueryStatusDiscontinued MangaSearchQueryStatus = "discontinued"
	MangaSearchQueryStatusHiatus       MangaSearchQueryStatus = "hiatus"
	MangaSearchQueryStatusPublishing   MangaSearchQueryStatus = "publishing"
	MangaSearchQueryStatusUpcoming     MangaSearchQueryStatus = "upcoming"
)

// Defines values for MangaSearchQueryType.
const (
	MangaSearchQueryTypeDoujin     MangaSearchQueryType = "doujin"
	MangaSearchQueryTypeLightnovel MangaSearchQueryType = "lightnovel"
	MangaSearchQueryTypeManga      MangaSearchQueryType = "manga"
	MangaSearchQueryTypeManhua     MangaSearchQueryType = "manhua"
	MangaSearchQueryTypeManhwa     MangaSearchQueryType = "manhwa"
	MangaSearchQueryTypeNovel      MangaSearchQueryType = "novel"
	MangaSearchQueryTypeOneshot    MangaSearchQueryType = "oneshot"
)

// Defines values for PeopleSearchQueryOrderby.
const (
	PeopleSearchQueryOrderbyBirthday  PeopleSearchQueryOrderby = "birthday"
	PeopleSearchQueryOrderbyFavorites PeopleSearchQueryOrderby = "favorites"
	PeopleSearchQueryOrderbyMalId     PeopleSearchQueryOrderby = "mal_id"
	PeopleSearchQueryOrderbyName      PeopleSearchQueryOrderby = "name"
)

// Defines values for ProducersQueryOrderby.
const (
	ProducersQueryOrderbyCount       ProducersQueryOrderby = "count"
	ProducersQueryOrderbyEstablished ProducersQueryOrderby = "established"
	ProducersQueryOrderbyFavorites   ProducersQueryOrderby = "favorites"
	ProducersQueryOrderbyMalId       ProducersQueryOrderby = "mal_id"
)

// Defines values for SearchQuerySort.
const (
	SearchQuerySortAsc  SearchQuerySort = "asc"
	SearchQuerySortDesc SearchQuerySort = "desc"
)

// Defines values for TopAnimeFilter.
const (
	TopAnimeFilterAiring       TopAnimeFilter = "airing"
	TopAnimeFilterBypopularity TopAnimeFilter = "bypopularity"
	TopAnimeFilterFavorite     TopAnimeFilter = "favorite"
	TopAnimeFilterUpcoming     TopAnimeFilter = "upcoming"
)

// Defines values for TopMangaFilter.
const (
	TopMangaFilterBypopularity TopMangaFilter = "bypopularity"
	TopMangaFilterFavorite     TopMangaFilter = "favorite"
	TopMangaFilterPublishing   TopMangaFilter = "publishing"
	TopMangaFilterUpcoming     TopMangaFilter = "upcoming"
)

// Defines values for TopReviewsTypeEnum.
const (
	TopReviewsTypeEnumAnime TopReviewsTypeEnum = "anime"
	TopReviewsTypeEnumManga TopReviewsTypeEnum = "manga"
)

// Defines values for UserAnimeListStatusFilter.
const (
	UserAnimeListStatusFilterAll         UserAnimeListStatusFilter = "all"
	UserAnimeListStatusFilterCompleted   UserAnimeListStatusFilter = "completed"
	UserAnimeListStatusFilterDropped     UserAnimeListStatusFilter = "dropped"
	UserAnimeListStatusFilterOnhold      UserAnimeListStatusFilter = "onhold"
	UserAnimeListStatusFilterPlantowatch UserAnimeListStatusFilter = "plantowatch"
	UserAnimeListStatusFilterWatching    UserAnimeListStatusFilter = "watching"
)

// Defines values for UserMangaListStatusFilter.
const (
	UserMangaListStatusFilterAll        UserMangaListStatusFilter = "all"
	UserMangaListStatusFilterCompleted  UserMangaListStatusFilter = "completed"
	UserMangaListStatusFilterDropped    UserMangaListStatusFilter = "dropped"
	UserMangaListStatusFilterOnhold     UserMangaListStatusFilter = "onhold"
	UserMangaListStatusFilterPlantoread UserMangaListStatusFilter = "plantoread"
	UserMangaListStatusFilterReading    UserMangaListStatusFilter = "reading"
)

// Defines values for UsersSearchQueryGender.
const (
	UsersSearchQueryGenderAny       UsersSearchQueryGender = "any"
	UsersSearchQueryGenderFemale    UsersSearchQueryGender = "female"
	UsersSearchQueryGenderMale      UsersSearchQueryGender = "male"
	UsersSearchQueryGenderNonbinary UsersSearchQueryGender = "nonbinary"
)

// Defines values for GetAnimeForumParamsFilter.
const (
	GetAnimeForumParamsFilterAll     GetAnimeForumParamsFilter = "all"
	GetAnimeForumParamsFilterEpisode GetAnimeForumParamsFilter = "episode"
	GetAnimeForumParamsFilterOther   GetAnimeForumParamsFilter = "other"
)

// Defines values for GetMangaTopicsParamsFilter.
const (
	GetMangaTopicsParamsFilterAll     GetMangaTopicsParamsFilter = "all"
	GetMangaTopicsParamsFilterEpisode GetMangaTopicsParamsFilter = "episode"
	GetMangaTopicsParamsFilterOther   GetMangaTopicsParamsFilter = "other"
)

// Defines values for GetSchedulesParamsFilter.
const (
	GetSchedulesParamsFilterFriday    GetSchedulesParamsFilter = "friday"
	GetSchedulesParamsFilterMonday    GetSchedulesParamsFilter = "monday"
	GetSchedulesParamsFilterOther     GetSchedulesParamsFilter = "other"
	GetSchedulesParamsFilterSaturday  GetSchedulesParamsFilter = "saturday"
	GetSchedulesParamsFilterSunday    GetSchedulesParamsFilter = "sunday"
	GetSchedulesParamsFilterThursday  GetSchedulesParamsFilter = "thursday"
	GetSchedulesParamsFilterTuesday   GetSchedulesParamsFilter = "tuesday"
	GetSchedulesParamsFilterUnknown   GetSchedulesParamsFilter = "unknown"
	GetSchedulesParamsFilterWednesday GetSchedulesParamsFilter = "wednesday"
)

// Defines values for GetSchedulesParamsKids.
const (
	GetSchedulesParamsKidsFalse GetSchedulesParamsKids = "false"
	GetSchedulesParamsKidsTrue  GetSchedulesParamsKids = "true"
)

// Defines values for GetSchedulesParamsSfw.
const (
	GetSchedulesParamsSfwFalse GetSchedulesParamsSfw = "false"
	GetSchedulesParamsSfwTrue  GetSchedulesParamsSfw = "true"
)

// Defines values for GetSeasonNowParamsFilter.
const (
	GetSeasonNowParamsFilterMovie   GetSeasonNowParamsFilter = "movie"
	GetSeasonNowParamsFilterMusic   GetSeasonNowParamsFilter = "music"
	GetSeasonNowParamsFilterOna     GetSeasonNowParamsFilter = "ona"
	GetSeasonNowParamsFilterOva     GetSeasonNowParamsFilter = "ova"
	GetSeasonNowParamsFilterSpecial GetSeasonNowParamsFilter = "special"
	GetSeasonNowParamsFilterTv      GetSeasonNowParamsFilter = "tv"
)

// Defines values for GetSeasonUpcomingParamsFilter.
const (
	GetSeasonUpcomingParamsFilterMovie   GetSeasonUpcomingParamsFilter = "movie"
	GetSeasonUpcomingParamsFilterMusic   GetSeasonUpcomingParamsFilter = "music"
	GetSeasonUpcomingParamsFilterOna     GetSeasonUpcomingParamsFilter = "ona"
	GetSeasonUpcomingParamsFilterOva     GetSeasonUpcomingParamsFilter = "ova"
	GetSeasonUpcomingParamsFilterSpecial GetSeasonUpcomingParamsFilter = "special"
	GetSeasonUpcomingParamsFilterTv      GetSeasonUpcomingParamsFilter = "tv"
)

// Defines values for GetSeasonParamsFilter.
const (
	GetSeasonParamsFilterMovie   GetSeasonParamsFilter = "movie"
	GetSeasonParamsFilterMusic   GetSeasonParamsFilter = "music"
	GetSeasonParamsFilterOna     GetSeasonParamsFilter = "ona"
	GetSeasonParamsFilterOva     GetSeasonParamsFilter = "ova"
	GetSeasonParamsFilterSpecial GetSeasonParamsFilter = "special"
	GetSeasonParamsFilterTv      GetSeasonParamsFilter = "tv"
)

// Defines values for GetUserHistoryParamsType.
const (
	GetUserHistoryParamsTypeAnime GetUserHistoryParamsType = "anime"
	GetUserHistoryParamsTypeManga GetUserHistoryParamsType = "manga"
)

// Anime Anime Resource
type Anime struct {
	// Aired Date range
	Aired *Daterange `json:"aired,omitempty"`

	// Airing Airing boolean
	Airing *bool `json:"airing,omitempty"`

	// Approved Whether the entry is pending approval on MAL or not
	Approved *bool `json:"approved,omitempty"`

	// Background Background
	Background *string `json:"background"`

	// Broadcast Broadcast Details
	Broadcast    *Broadcast `json:"broadcast,omitempty"`
	Demographics *[]MalUrl  `json:"demographics,omitempty"`

	// Duration Parsed raw duration
	Duration *string `json:"duration"`

	// Episodes Episode count
	Episodes       *int      `json:"episodes"`
	ExplicitGenres *[]MalUrl `json:"explicit_genres,omitempty"`

	// Favorites Number of users who have favorited this entry
	Favorites *int         `json:"favorites"`
	Genres    *[]MalUrl    `json:"genres,omitempty"`
	Images    *AnimeImages `json:"images,omitempty"`
	Licensors *[]MalUrl    `json:"licensors,omitempty"`

	// MalId MyAnimeList ID
	MalId *int `json:"mal_id,omitempty"`

	// Members Number of users who have added this entry to their list
	Members *int `json:"members"`

	// Popularity Popularity
	Popularity *int      `json:"popularity"`
	Producers  *[]MalUrl `json:"producers,omitempty"`

	// Rank Ranking
	Rank *int `json:"rank"`

	// Rating Anime audience rating
	Rating *AnimeRating `json:"rating"`

	// Score Score
	Score *float32 `json:"score"`

	// ScoredBy Number of users
	ScoredBy *int `json:"scored_by"`

	// Season Season
	Season *AnimeSeason `json:"season"`

	// Source Original Material/Source adapted from
	Source *string `json:"source"`

	// Status Airing status
	Status  *AnimeStatus `json:"status"`
	Studios *[]MalUrl    `json:"studios,omitempty"`

	// Synopsis Synopsis
	Synopsis *string   `json:"synopsis"`
	Themes   *[]MalUrl `json:"themes,omitempty"`

	// Title Title
	// Deprecated:
	Title *string `json:"title,omitempty"`

	// TitleEnglish English Title
	// Deprecated:
	TitleEnglish *string `json:"title_english"`

	// TitleJapanese Japanese Title
	// Deprecated:
	TitleJapanese *string `json:"title_japanese"`

	// TitleSynonyms Other Titles
	// Deprecated:
	TitleSynonyms *[]string `json:"title_synonyms,omitempty"`

	// Titles All titles
	Titles *[]Title `json:"titles,omitempty"`

	// Trailer Youtube Details
	Trailer *TrailerBase `json:"trailer,omitempty"`

	// Type Anime Type
	Type *AnimeType `json:"type"`

	// Url MyAnimeList URL
	Url *string `json:"url,omitempty"`

	// Year Year
	Year *int `json:"year"`
}

// AnimeRating Anime audience rating
type AnimeRating string

// AnimeSeason Season
type AnimeSeason string

// AnimeStatus Airing status
type AnimeStatus string

// AnimeType Anime Type
type AnimeType string

// AnimeCharacters Anime Characters Resource
type AnimeCharacters struct {
	Data *[]struct {
		// Character Character details
		Character *struct {
			Images *CharacterImages `json:"images,omitempty"`

			// MalId MyAnimeList ID
			MalId *int `json:"mal_id,omitempty"`

			// Name Character Name
			Name *string `json:"name,omitempty"`

			// Url MyAnimeList URL
			Url *string `json:"url,omitempty"`
		} `json:"character,omitempty"`

		// Role Character's Role
		Role        *string `json:"role,omitempty"`
		VoiceActors *[]struct {
			Language *string `json:"language,omitempty"`
			Person   *struct {
				Images *PeopleImages `json:"images,omitempty"`
				MalId  *int          `json:"mal_id,omitempty"`
				Name   *string       `json:"name,omitempty"`
				Url    *string       `json:"url,omitempty"`
			} `json:"person,omitempty"`
		} `json:"voice_actors,omitempty"`
	} `json:"data,omitempty"`
}

// AnimeEpisode Anime Episode Resource
type AnimeEpisode struct {
	// Aired Aired Date ISO8601
	Aired *string `json:"aired"`

	// Duration Episode duration in seconds
	Duration *int `json:"duration"`

	// Filler Filler episode
	Filler *bool `json:"filler,omitempty"`

	// MalId MyAnimeList ID
	MalId *int `json:"mal_id,omitempty"`

	// Recap Recap episode
	Recap *bool `json:"recap,omitempty"`

	// Synopsis Episode Synopsis
	Synopsis *string `json:"synopsis"`

	// Title Title
	Title *string `json:"title,omitempty"`

	// TitleJapanese Title Japanese
	TitleJapanese *string `json:"title_japanese"`

	// TitleRomanji title_romanji
	TitleRomanji *string `json:"title_romanji"`

	// Url MyAnimeList URL
	Url *string `json:"url,omitempty"`
}

// AnimeEpisodes defines model for anime_episodes.
type AnimeEpisodes struct {
	Data *[]struct {
		// Aired Aired Date ISO8601
		Aired *string `json:"aired"`

		// Filler Filler episode
		Filler *bool `json:"filler,omitempty"`

		// ForumUrl Episode discussion forum URL
		ForumUrl *string `json:"forum_url"`

		// MalId MyAnimeList ID
		MalId *int `json:"mal_id,omitempty"`

		// Recap Recap episode
		Recap *bool `json:"recap,omitempty"`

		// Score Aggregated episode score (1.00 - 5.00) based on MyAnimeList user voting
		Score *float32 `json:"score"`

		// Title Title
		Title *string `json:"title,omitempty"`

		// TitleJapanese Title Japanese
		TitleJapanese *string `json:"title_japanese"`

		// TitleRomanji title_romanji
		TitleRomanji *string `json:"title_romanji"`

		// Url MyAnimeList URL. This is the URL of the episode's video. If there is no video url, this will be null.
		Url *string `json:"url"`
	} `json:"data,omitempty"`
	Pagination *struct {
		HasNextPage     *bool `json:"has_next_page,omitempty"`
		LastVisiblePage *int  `json:"last_visible_page,omitempty"`
	} `json:"pagination,omitempty"`
}

// AnimeFull Full anime Resource
type AnimeFull struct {
	// Aired Date range
	Aired *Daterange `json:"aired,omitempty"`

	// Airing Airing boolean
	Airing *bool `json:"airing,omitempty"`

	// Approved Whether the entry is pending approval on MAL or not
	Approved *bool `json:"approved,omitempty"`

	// Background Background
	Background *string `json:"background"`

	// Broadcast Broadcast Details
	Broadcast    *Broadcast `json:"broadcast,omitempty"`
	Demographics *[]MalUrl  `json:"demographics,omitempty"`

	// Duration Parsed raw duration
	Duration *string `json:"duration"`

	// Episodes Episode count
	Episodes       *int      `json:"episodes"`
	ExplicitGenres *[]MalUrl `json:"explicit_genres,omitempty"`
	External       *[]struct {
		Name *string `json:"name,omitempty"`
		Url  *string `json:"url,omitempty"`
	} `json:"external,omitempty"`

	// Favorites Number of users who have favorited this entry
	Favorites *int         `json:"favorites"`
	Genres    *[]MalUrl    `json:"genres,omitempty"`
	Images    *AnimeImages `json:"images,omitempty"`
	Licensors *[]MalUrl    `json:"licensors,omitempty"`

	// MalId MyAnimeList ID
	MalId *int `json:"mal_id,omitempty"`

	// Members Number of users who have added this entry to their list
	Members *int `json:"members"`

	// Popularity Popularity
	Popularity *int      `json:"popularity"`
	Producers  *[]MalUrl `json:"producers,omitempty"`

	// Rank Ranking
	Rank *int `json:"rank"`

	// Rating Anime audience rating
	Rating    *AnimeFullRating `json:"rating"`
	Relations *[]struct {
		Entry *[]MalUrl `json:"entry,omitempty"`

		// Relation Relation type
		Relation *string `json:"relation,omitempty"`
	} `json:"relations,omitempty"`

	// Score Score
	Score *float32 `json:"score"`

	// ScoredBy Number of users
	ScoredBy *int `json:"scored_by"`

	// Season Season
	Season *AnimeFullSeason `json:"season"`

	// Source Original Material/Source adapted from
	Source *string `json:"source"`

	// Status Airing status
	Status    *AnimeFullStatus `json:"status"`
	Streaming *[]struct {
		Name *string `json:"name,omitempty"`
		Url  *string `json:"url,omitempty"`
	} `json:"streaming,omitempty"`
	Studios *[]MalUrl `json:"studios,omitempty"`

	// Synopsis Synopsis
	Synopsis *string `json:"synopsis"`
	Theme    *struct {
		Endings  *[]string `json:"endings,omitempty"`
		Openings *[]string `json:"openings,omitempty"`
	} `json:"theme,omitempty"`
	Themes *[]MalUrl `json:"themes,omitempty"`

	// Title Title
	// Deprecated:
	Title *string `json:"title,omitempty"`

	// TitleEnglish English Title
	// Deprecated:
	TitleEnglish *string `json:"title_english"`

	// TitleJapanese Japanese Title
	// Deprecated:
	TitleJapanese *string `json:"title_japanese"`

	// TitleSynonyms Other Titles
	// Deprecated:
	TitleSynonyms *[]string `json:"title_synonyms,omitempty"`

	// Titles All titles
	Titles *[]Title `json:"titles,omitempty"`

	// Trailer Youtube Details
	Trailer *TrailerBase `json:"trailer,omitempty"`

	// Type Anime Type
	Type *AnimeFullType `json:"type"`

	// Url MyAnimeList URL
	Url *string `json:"url,omitempty"`

	// Year Year
	Year *int `json:"year"`
}

// AnimeFullRating Anime audience rating
type AnimeFullRating string

// AnimeFullSeason Season
type AnimeFullSeason string

// AnimeFullStatus Airing status
type AnimeFullStatus string

// AnimeFullType Anime Type
type AnimeFullType string

// AnimeImages defines model for anime_images.
type AnimeImages struct {
	// Jpg Available images in JPG
	Jpg *struct {
		// ImageUrl Image URL JPG
		ImageUrl *string `json:"image_url"`

		// LargeImageUrl Image URL JPG
		LargeImageUrl *string `json:"large_image_url"`

		// SmallImageUrl Small Image URL JPG
		SmallImageUrl *string `json:"small_image_url"`
	} `json:"jpg,omitempty"`

	// Webp Available images in WEBP
	Webp *struct {
		// ImageUrl Image URL WEBP
		ImageUrl *string `json:"image_url"`

		// LargeImageUrl Image URL WEBP
		LargeImageUrl *string `json:"large_image_url"`

		// SmallImageUrl Small Image URL WEBP
		SmallImageUrl *string `json:"small_image_url"`
	} `json:"webp,omitempty"`
}

// AnimeMeta defines model for anime_meta.
type AnimeMeta struct {
	Images *AnimeImages `json:"images,omitempty"`

	// MalId MyAnimeList ID
	MalId *int `json:"mal_id,omitempty"`

	// Title Entry title
	Title *string `json:"title,omitempty"`

	// Url MyAnimeList URL
	Url *string `json:"url,omitempty"`
}

// AnimeNews defines model for anime_news.
type AnimeNews struct {
	Data *[]struct {
		// AuthorUrl Author Profile URL
		AuthorUrl *string `json:"author_url,omitempty"`

		// AuthorUsername Author MyAnimeList Username
		AuthorUsername *string `json:"author_username,omitempty"`

		// Comments Comment count
		Comments *int `json:"comments,omitempty"`

		// Date Post Date ISO8601
		Date *string `json:"date,omitempty"`

		// Excerpt Excerpt
		Excerpt *string `json:"excerpt,omitempty"`

		// ForumUrl Forum topic URL
		ForumUrl *string       `json:"forum_url,omitempty"`
		Images   *CommonImages `json:"images,omitempty"`

		// MalId MyAnimeList ID
		MalId *int `json:"mal_id,omitempty"`

		// Title Title
		Title *string `json:"title,omitempty"`

		// Url MyAnimeList URL
		Url *string `json:"url,omitempty"`
	} `json:"data,omitempty"`
	Pagination *struct {
		HasNextPage     *bool `json:"has_next_page,omitempty"`
		LastVisiblePage *int  `json:"last_visible_page,omitempty"`
	} `json:"pagination,omitempty"`
}

// AnimeRelations Anime Relations
type AnimeRelations struct {
	Data *[]struct {
		Entry *[]MalUrl `json:"entry,omitempty"`

		// Relation Relation type
		Relation *string `json:"relation,omitempty"`
	} `json:"data,omitempty"`
}

// AnimeReview defines model for anime_review.
type AnimeReview struct {
	// Date Review created date ISO8601
	Date *string `json:"date,omitempty"`

	// EpisodesWatched Number of episodes watched
	EpisodesWatched *int `json:"episodes_watched,omitempty"`

	// IsPreliminary The review was made before the entry was completed
	IsPreliminary *bool `json:"is_preliminary,omitempty"`

	// IsSpoiler The review contains spoiler
	IsSpoiler *bool `json:"is_spoiler,omitempty"`

	// MalId MyAnimeList ID
	MalId *int `json:"mal_id,omitempty"`

	// Reactions User reaction count on the review
	Reactions *struct {
		// Confusing Confusing reaction count
		Confusing *int `json:"confusing,omitempty"`

		// Creative Creative reaction count
		Creative *int `json:"creative,omitempty"`

		// Funny Funny reaction count
		Funny *int `json:"funny,omitempty"`

		// Informative Informative reaction count
		Informative *int `json:"informative,omitempty"`

		// LoveIt Love it reaction count
		LoveIt *int `json:"love_it,omitempty"`

		// Nice Nice reaction count
		Nice *int `json:"nice,omitempty"`

		// Overall Overall reaction count
		Overall *int `json:"overall,omitempty"`

		// WellWritten Well written reaction count
		WellWritten *int `json:"well_written,omitempty"`
	} `json:"reactions,omitempty"`

	// Review Review content
	Review *string `json:"review,omitempty"`

	// Score Number of user votes on the Review
	Score *int `json:"score,omitempty"`

	// Tags Review tags
	Tags *[]string `json:"tags,omitempty"`

	// Type Entry type
	Type *string `json:"type,omitempty"`

	// Url MyAnimeList review URL
	Url *string `json:"url,omitempty"`
}

// AnimeReviews defines model for anime_reviews.
type AnimeReviews struct {
	Data *[]struct {
		// Date Review created date ISO8601
		Date *string `json:"date,omitempty"`

		// EpisodesWatched Number of episodes watched
		EpisodesWatched *int `json:"episodes_watched,omitempty"`

		// IsPreliminary The review was made before the entry was completed
		IsPreliminary *bool `json:"is_preliminary,omitempty"`

		// IsSpoiler The review contains spoiler
		IsSpoiler *bool `json:"is_spoiler,omitempty"`

		// MalId MyAnimeList ID
		MalId *int `json:"mal_id,omitempty"`

		// Reactions User reaction count on the review
		Reactions *struct {
			// Confusing Confusing reaction count
			Confusing *int `json:"confusing,omitempty"`

			// Creative Creative reaction count
			Creative *int `json:"creative,omitempty"`

			// Funny Funny reaction count
			Funny *int `json:"funny,omitempty"`

			// Informative Informative reaction count
			Informative *int `json:"informative,omitempty"`

			// LoveIt Love it reaction count
			LoveIt *int `json:"love_it,omitempty"`

			// Nice Nice reaction count
			Nice *int `json:"nice,omitempty"`

			// Overall Overall reaction count
			Overall *int `json:"overall,omitempty"`

			// WellWritten Well written reaction count
			WellWritten *int `json:"well_written,omitempty"`
		} `json:"reactions,omitempty"`

		// Review Review content
		Review *string `json:"review,omitempty"`

		// Score Number of user votes on the Review
		Score *int `json:"score,omitempty"`

		// Tags Review tags
		Tags *[]string `json:"tags,omitempty"`

		// Type Entry type
		Type *string `json:"type,omitempty"`

		// Url MyAnimeList review URL
		Url  *string   `json:"url,omitempty"`
		User *UserMeta `json:"user,omitempty"`
	} `json:"data,omitempty"`
	Pagination *struct {
		HasNextPage     *bool `json:"has_next_page,omitempty"`
		LastVisiblePage *int  `json:"last_visible_page,omitempty"`
	} `json:"pagination,omitempty"`
}

// AnimeSearch defines model for anime_search.
type AnimeSearch struct {
	Data       *[]Anime `json:"data,omitempty"`
	Pagination *struct {
		HasNextPage *bool `json:"has_next_page,omitempty"`
		Items       *struct {
			Count   *int `json:"count,omitempty"`
			PerPage *int `json:"per_page,omitempty"`
			Total   *int `json:"total,omitempty"`
		} `json:"items,omitempty"`
		LastVisiblePage *int `json:"last_visible_page,omitempty"`
	} `json:"pagination,omitempty"`
}

// AnimeSearchQueryOrderby Available Anime order_by properties
type AnimeSearchQueryOrderby string

// AnimeSearchQueryRating Available Anime audience ratings<br><br><b>Ratings</b><br><ul><li>G - All Ages</li><li>PG - Children</li><li>PG-13 - Teens 13 or older</li><li>R - 17+ (violence & profanity)</li><li>R+ - Mild Nudity</li><li>Rx - Hentai</li></ul>
type AnimeSearchQueryRating string

// AnimeSearchQueryStatus Available Anime statuses
type AnimeSearchQueryStatus string

// AnimeSearchQueryType Available Anime types
type AnimeSearchQueryType string

// AnimeStaff Anime Staff Resource
type AnimeStaff struct {
	Data *[]struct {
		// Person Person details
		Person *struct {
			Images *PeopleImages `json:"images,omitempty"`

			// MalId MyAnimeList ID
			MalId *int `json:"mal_id,omitempty"`

			// Name Name
			Name *string `json:"name,omitempty"`

			// Url MyAnimeList URL
			Url *string `json:"url,omitempty"`
		} `json:"person,omitempty"`

		// Positions Staff Positions
		Positions *[]string `json:"positions,omitempty"`
	} `json:"data,omitempty"`
}

// AnimeStatistics Anime Statistics Resource
type AnimeStatistics struct {
	Data *struct {
		// Completed Number of users who have completed the resource
		Completed *int `json:"completed,omitempty"`

		// Dropped Number of users who have dropped the resource
		Dropped *int `json:"dropped,omitempty"`

		// OnHold Number of users who have put the resource on hold
		OnHold *int `json:"on_hold,omitempty"`

		// PlanToWatch Number of users who have planned to watch the resource
		PlanToWatch *int `json:"plan_to_watch,omitempty"`
		Scores      *[]struct {
			// Percentage Percentage of votes for this score
			Percentage *float32 `json:"percentage,omitempty"`

			// Score Scoring value
			Score *int `json:"score,omitempty"`

			// Votes Number of votes for this score
			Votes *int `json:"votes,omitempty"`
		} `json:"scores,omitempty"`

		// Total Total number of users who have the resource added to their lists
		Total *int `json:"total,omitempty"`

		// Watching Number of users watching the resource
		Watching *int `json:"watching,omitempty"`
	} `json:"data,omitempty"`
}

// AnimeThemes Anime Opening and Ending Themes
type AnimeThemes struct {
	Data *struct {
		Endings  *[]string `json:"endings,omitempty"`
		Openings *[]string `json:"openings,omitempty"`
	} `json:"data,omitempty"`
}

// AnimeUserupdates defines model for anime_userupdates.
type AnimeUserupdates struct {
	Data *[]struct {
		// Date Last updated date ISO8601
		Date *string `json:"date,omitempty"`

		// EpisodesSeen Number of episodes seen
		EpisodesSeen *int `json:"episodes_seen"`

		// EpisodesTotal Total number of episodes
		EpisodesTotal *int `json:"episodes_total"`

		// Score User Score
		Score *int `json:"score"`

		// Status User list status
		Status *string   `json:"status,omitempty"`
		User   *UserMeta `json:"user,omitempty"`
	} `json:"data,omitempty"`
	Pagination *struct {
		HasNextPage     *bool `json:"has_next_page,omitempty"`
		LastVisiblePage *int  `json:"last_visible_page,omitempty"`
	} `json:"pagination,omitempty"`
}

// AnimeVideos Anime Videos Resource
type AnimeVideos struct {
	Data *struct {
		Episodes *[]struct {
			// Episode Episode
			Episode *string       `json:"episode,omitempty"`
			Images  *CommonImages `json:"images,omitempty"`

			// MalId MyAnimeList ID
			MalId *int `json:"mal_id,omitempty"`

			// Title Title
			Title *string `json:"title,omitempty"`

			// Url MyAnimeList URL
			Url *string `json:"url,omitempty"`
		} `json:"episodes,omitempty"`
		MusicVideos *[]struct {
			Meta *struct {
				Author *string `json:"author"`
				Title  *string `json:"title"`
			} `json:"meta,omitempty"`

			// Title Title
			Title *string `json:"title,omitempty"`

			// Video Youtube Details
			Video *Trailer `json:"video,omitempty"`
		} `json:"music_videos,omitempty"`
		Promo *[]struct {
			// Title Title
			Title *string `json:"title,omitempty"`

			// Trailer Youtube Details
			Trailer *Trailer `json:"trailer,omitempty"`
		} `json:"promo,omitempty"`
	} `json:"data,omitempty"`
}

// AnimeVideosEpisodes defines model for anime_videos_episodes.
type AnimeVideosEpisodes struct {
	Data *[]struct {
		// Episode Episode Subtitle
		Episode *string       `json:"episode,omitempty"`
		Images  *CommonImages `json:"images,omitempty"`

		// MalId MyAnimeList ID or Episode Number
		MalId *int `json:"mal_id,omitempty"`

		// Title Episode Title
		Title *string `json:"title,omitempty"`

		// Url Episode Page URL
		Url *string `json:"url,omitempty"`
	} `json:"data,omitempty"`
	Pagination *struct {
		HasNextPage     *bool `json:"has_next_page,omitempty"`
		LastVisiblePage *int  `json:"last_visible_page,omitempty"`
	} `json:"pagination,omitempty"`
}

// Broadcast Broadcast Details
type Broadcast struct {
	// Day Day of the week
	Day *string `json:"day"`

	// String Raw parsed broadcast string
	String *string `json:"string"`

	// Time Time in 24 hour format
	Time *string `json:"time"`

	// Timezone Timezone (Tz Database format https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)
	Timezone *string `json:"timezone"`
}

// Character Character Resource
type Character struct {
	// About Biography
	About *string `json:"about"`

	// Favorites Number of users who have favorited this entry
	Favorites *int             `json:"favorites,omitempty"`
	Images    *CharacterImages `json:"images,omitempty"`

	// MalId MyAnimeList ID
	MalId *int `json:"mal_id,omitempty"`

	// Name Name
	Name *string `json:"name,omitempty"`

	// NameKanji Name
	NameKanji *string `json:"name_kanji"`

	// Nicknames Other Names
	Nicknames *[]string `json:"nicknames,omitempty"`

	// Url MyAnimeList URL
	Url *string `json:"url,omitempty"`
}

// CharacterAnime Character casted in anime
type CharacterAnime struct {
	Data *[]struct {
		Anime *AnimeMeta `json:"anime,omitempty"`

		// Role Character's Role
		Role *string `json:"role,omitempty"`
	} `json:"data,omitempty"`
}

// CharacterFull Character Resource
type CharacterFull struct {
	// About Biography
	About *string `json:"about"`
	Anime *[]struct {
		Anime *AnimeMeta `json:"anime,omitempty"`

		// Role Character's Role
		Role *string `json:"role,omitempty"`
	} `json:"anime,omitempty"`

	// Favorites Number of users who have favorited this entry
	Favorites *int             `json:"favorites,omitempty"`
	Images    *CharacterImages `json:"images,omitempty"`

	// MalId MyAnimeList ID
	MalId *int `json:"mal_id,omitempty"`
	Manga *[]struct {
		Manga *MangaMeta `json:"manga,omitempty"`

		// Role Character's Role
		Role *string `json:"role,omitempty"`
	} `json:"manga,omitempty"`

	// Name Name
	Name *string `json:"name,omitempty"`

	// NameKanji Name
	NameKanji *string `json:"name_kanji"`

	// Nicknames Other Names
	Nicknames *[]string `json:"nicknames,omitempty"`

	// Url MyAnimeList URL
	Url    *string `json:"url,omitempty"`
	Voices *[]struct {
		// Language Character's Role
		Language *string     `json:"language,omitempty"`
		Person   *PersonMeta `json:"person,omitempty"`
	} `json:"voices,omitempty"`
}

// CharacterImages defines model for character_images.
type CharacterImages struct {
	// Jpg Available images in JPG
	Jpg *struct {
		// ImageUrl Image URL JPG
		ImageUrl *string `json:"image_url"`

		// SmallImageUrl Small Image URL JPG
		SmallImageUrl *string `json:"small_image_url"`
	} `json:"jpg,omitempty"`

	// Webp Available images in WEBP
	Webp *struct {
		// ImageUrl Image URL WEBP
		ImageUrl *string `json:"image_url"`

		// SmallImageUrl Small Image URL WEBP
		SmallImageUrl *string `json:"small_image_url"`
	} `json:"webp,omitempty"`
}

// CharacterManga Character casted in manga
type CharacterManga struct {
	Data *[]struct {
		Manga *MangaMeta `json:"manga,omitempty"`

		// Role Character's Role
		Role *string `json:"role,omitempty"`
	} `json:"data,omitempty"`
}

// CharacterMeta defines model for character_meta.
type CharacterMeta struct {
	Images *CharacterImages `json:"images,omitempty"`

	// MalId MyAnimeList ID
	MalId *int `json:"mal_id,omitempty"`

	// Name Entry name
	Name *string `json:"name,omitempty"`

	// Url MyAnimeList URL
	Url *string `json:"url,omitempty"`
}

// CharacterPictures Character Pictures
type CharacterPictures struct {
	Data *[]struct {
		// ImageUrl Default JPG Image Size URL
		ImageUrl *string `json:"image_url"`

		// LargeImageUrl Large JPG Image Size URL
		LargeImageUrl *string `json:"large_image_url"`
	} `json:"data,omitempty"`
}

// CharacterVoiceActors Character voice actors
type CharacterVoiceActors struct {
	Data *[]struct {
		// Language Character's Role
		Language *string     `json:"language,omitempty"`
		Person   *PersonMeta `json:"person,omitempty"`
	} `json:"data,omitempty"`
}

// CharactersSearch defines model for characters_search.
type CharactersSearch struct {
	Data       *[]Character `json:"data,omitempty"`
	Pagination *struct {
		HasNextPage *bool `json:"has_next_page,omitempty"`
		Items       *struct {
			Count   *int `json:"count,omitempty"`
			PerPage *int `json:"per_page,omitempty"`
			Total   *int `json:"total,omitempty"`
		} `json:"items,omitempty"`
		LastVisiblePage *int `json:"last_visible_page,omitempty"`
	} `json:"pagination,omitempty"`
}

// CharactersSearchQueryOrderby Available Character order_by properties
type CharactersSearchQueryOrderby string

// Club Club Resource
type Club struct {
	// Access Club access
	Access *ClubAccess `json:"access,omitempty"`

	// Category Club Category
	Category *ClubCategory `json:"category,omitempty"`

	// Created Date Created ISO8601
	Created *string       `json:"created,omitempty"`
	Images  *CommonImages `json:"images,omitempty"`

	// MalId MyAnimeList ID
	MalId *int `json:"mal_id,omitempty"`

	// Members Number of club members
	Members *int `json:"members,omitempty"`

	// Name Club name
	Name *string `json:"name,omitempty"`

	// Url Club URL
	Url *string `json:"url,omitempty"`
}

// ClubAccess Club access
type ClubAccess string

// ClubCategory Club Category
type ClubCategory string

// ClubMember Club Member
type ClubMember struct {
	Data *[]struct {
		Images *UserImages `json:"images,omitempty"`

		// Url User URL
		Url *string `json:"url,omitempty"`

		// Username User's username
		Username *string `json:"username,omitempty"`
	} `json:"data,omitempty"`
}

// ClubRelations Club Relations
type ClubRelations struct {
	Data *struct {
		Anime      *[]MalUrl `json:"anime,omitempty"`
		Characters *[]MalUrl `json:"characters,omitempty"`
		Manga      *[]MalUrl `json:"manga,omitempty"`
	} `json:"data,omitempty"`
}

// ClubSearchQueryCategory Club Search Query Category
type ClubSearchQueryCategory string

// ClubSearchQueryOrderby Club Search Query OrderBy
type ClubSearchQueryOrderby string

// ClubSearchQueryType Club Search Query Type
type ClubSearchQueryType string

// ClubStaff Club Staff Resource
type ClubStaff struct {
	Data *[]struct {
		// Url User URL
		Url *string `json:"url,omitempty"`

		// Username User's username
		Username *string `json:"username,omitempty"`
	} `json:"data,omitempty"`
}

// ClubsSearch defines model for clubs_search.
type ClubsSearch struct {
	Data       *[]Club `json:"data,omitempty"`
	Pagination *struct {
		HasNextPage     *bool `json:"has_next_page,omitempty"`
		LastVisiblePage *int  `json:"last_visible_page,omitempty"`
	} `json:"pagination,omitempty"`
}

// CommonImages defines model for common_images.
type CommonImages struct {
	// Jpg Available images in JPG
	Jpg *struct {
		// ImageUrl Image URL JPG
		ImageUrl *string `json:"image_url"`
	} `json:"jpg,omitempty"`
}

// Daterange Date range
type Daterange struct {
	// From Date ISO8601
	From *string `json:"from"`

	// Prop Date Prop
	Prop *struct {
		// From Date Prop From
		From *struct {
			// Day Day
			Day *int `json:"day"`

			// Month Month
			Month *int `json:"month"`

			// Year Year
			Year *int `json:"year"`
		} `json:"from,omitempty"`

		// String Raw parsed string
		String *string `json:"string"`

		// To Date Prop To
		To *struct {
			// Day Day
			Day *int `json:"day"`

			// Month Month
			Month *int `json:"month"`

			// Year Year
			Year *int `json:"year"`
		} `json:"to,omitempty"`
	} `json:"prop,omitempty"`

	// To Date ISO8601
	To *string `json:"to"`
}

// EntryMeta Entry Meta data
type EntryMeta struct {
	// ImageUrl Image URL
	ImageUrl *string `json:"image_url,omitempty"`

	// MalId MyAnimeList ID
	MalId *int `json:"mal_id,omitempty"`

	// Name Entry Name/Title
	Name *string `json:"name,omitempty"`

	// Url MyAnimeList URL
	Url *string `json:"url,omitempty"`
}

// EntryRecommendations Entry Recommendations Resource
type EntryRecommendations struct {
	Data *[]struct {
		Entry *EntryRecommendations_Data_Entry `json:"entry,omitempty"`
	} `json:"data,omitempty"`
}

// EntryRecommendations_Data_Entry defines model for EntryRecommendations.Data.Entry.
type EntryRecommendations_Data_Entry struct {
	union json.RawMessage
}

// ExternalLinks External links
type ExternalLinks struct {
	Data *[]struct {
		Name *string `json:"name,omitempty"`
		Url  *string `json:"url,omitempty"`
	} `json:"data,omitempty"`
}

// Forum Forum Resource
type Forum struct {
	Data *[]struct {
		// AuthorUrl Author Profile URL
		AuthorUrl *string `json:"author_url,omitempty"`

		// AuthorUsername Author MyAnimeList Username
		AuthorUsername *string `json:"author_username,omitempty"`

		// Comments Comment count
		Comments *int `json:"comments,omitempty"`

		// Date Post Date ISO8601
		Date *string `json:"date,omitempty"`

		// LastComment Last comment details
		LastComment *struct {
			// AuthorUrl Author Profile URL
			AuthorUrl *string `json:"author_url,omitempty"`

			// AuthorUsername Author MyAnimeList Username
			AuthorUsername *string `json:"author_username,omitempty"`

			// Date Last comment date posted ISO8601
			Date *string `json:"date"`

			// Url Last comment URL
			Url *string `json:"url,omitempty"`
		} `json:"last_comment,omitempty"`

		// MalId MyAnimeList ID
		MalId *int `json:"mal_id,omitempty"`

		// Title Title
		Title *string `json:"title,omitempty"`

		// Url MyAnimeList URL
		Url *string `json:"url,omitempty"`
	} `json:"data,omitempty"`
}

// Genre Genre Resource
type Genre struct {
	// Count Genre's entry count
	Count *int `json:"count,omitempty"`

	// MalId MyAnimeList ID
	MalId *int `json:"mal_id,omitempty"`

	// Name Genre Name
	Name *string `json:"name,omitempty"`

	// Url MyAnimeList URL
	Url *string `json:"url,omitempty"`
}

// GenreQueryFilter Filter genres by type
type GenreQueryFilter string

// Genres Genres Collection Resource
type Genres struct {
	Data *[]Genre `json:"data,omitempty"`
}

// History Transform the resource into an array.
type History struct {
	// Date Date ISO8601
	Date *string `json:"date,omitempty"`

	// Entry Parsed URL Data
	Entry *MalUrl `json:"entry,omitempty"`

	// Increment Number of episodes/chapters watched/read
	Increment *int `json:"increment,omitempty"`
}

// Magazine Magazine Resource
type Magazine struct {
	// Count Magazine's manga count
	Count *int `json:"count,omitempty"`

	// MalId MyAnimeList ID
	MalId *int `json:"mal_id,omitempty"`

	// Name Magazine Name
	Name *string `json:"name,omitempty"`

	// Url MyAnimeList URL
	Url *string `json:"url,omitempty"`
}

// Magazines defines model for magazines.
type Magazines struct {
	Data       *[]Magazine `json:"data,omitempty"`
	Pagination *struct {
		HasNextPage     *bool `json:"has_next_page,omitempty"`
		LastVisiblePage *int  `json:"last_visible_page,omitempty"`
	} `json:"pagination,omitempty"`
}

// MagazinesQueryOrderby Order by magazine data
type MagazinesQueryOrderby string

// MalUrl Parsed URL Data
type MalUrl struct {
	// MalId MyAnimeList ID
	MalId *int `json:"mal_id,omitempty"`

	// Name Resource Name/Title
	Name *string `json:"name,omitempty"`

	// Type Type of resource
	Type *string `json:"type,omitempty"`

	// Url MyAnimeList URL
	Url *string `json:"url,omitempty"`
}

// MalUrl2 Parsed URL Data
type MalUrl2 struct {
	// MalId MyAnimeList ID
	MalId *int `json:"mal_id,omitempty"`

	// Title Resource Name/Title
	Title *string `json:"title,omitempty"`

	// Type Type of resource
	Type *string `json:"type,omitempty"`

	// Url MyAnimeList URL
	Url *string `json:"url,omitempty"`
}

// Manga Manga Resource
type Manga struct {
	// Approved Whether the entry is pending approval on MAL or not
	Approved *bool     `json:"approved,omitempty"`
	Authors  *[]MalUrl `json:"authors,omitempty"`

	// Background Background
	Background *string `json:"background"`

	// Chapters Chapter count
	Chapters       *int      `json:"chapters"`
	Demographics   *[]MalUrl `json:"demographics,omitempty"`
	ExplicitGenres *[]MalUrl `json:"explicit_genres,omitempty"`

	// Favorites Number of users who have favorited this entry
	Favorites *int         `json:"favorites"`
	Genres    *[]MalUrl    `json:"genres,omitempty"`
	Images    *MangaImages `json:"images,omitempty"`

	// MalId MyAnimeList ID
	MalId *int `json:"mal_id,omitempty"`

	// Members Number of users who have added this entry to their list
	Members *int `json:"members"`

	// Popularity Popularity
	Popularity *int `json:"popularity"`

	// Published Date range
	Published *Daterange `json:"published,omitempty"`

	// Publishing Publishing boolean
	Publishing *bool `json:"publishing,omitempty"`

	// Rank Ranking
	Rank *int `json:"rank"`

	// Score Score
	Score *float32 `json:"score"`

	// ScoredBy Number of users
	ScoredBy       *int      `json:"scored_by"`
	Serializations *[]MalUrl `json:"serializations,omitempty"`

	// Status Publishing status
	Status *MangaStatus `json:"status,omitempty"`

	// Synopsis Synopsis
	Synopsis *string   `json:"synopsis"`
	Themes   *[]MalUrl `json:"themes,omitempty"`

	// Title Title
	// Deprecated:
	Title *string `json:"title,omitempty"`

	// TitleEnglish English Title
	// Deprecated:
	TitleEnglish *string `json:"title_english"`

	// TitleJapanese Japanese Title
	// Deprecated:
	TitleJapanese *string `json:"title_japanese"`

	// Titles All Titles
	Titles *[]Title `json:"titles,omitempty"`

	// Type Manga Type
	Type *MangaType `json:"type"`

	// Url MyAnimeList URL
	Url *string `json:"url,omitempty"`

	// Volumes Volume count
	Volumes *int `json:"volumes"`
}

// MangaStatus Publishing status
type MangaStatus string

// MangaType Manga Type
type MangaType string

// MangaCharacters Manga Characters Resource
type MangaCharacters struct {
	Data *[]struct {
		Character *CharacterMeta `json:"character,omitempty"`

		// Role Character's Role
		Role *string `json:"role,omitempty"`
	} `json:"data,omitempty"`
}

// MangaFull Manga Resource
type MangaFull struct {
	// Approved Whether the entry is pending approval on MAL or not
	Approved *bool     `json:"approved,omitempty"`
	Authors  *[]MalUrl `json:"authors,omitempty"`

	// Background Background
	Background *string `json:"background"`

	// Chapters Chapter count
	Chapters       *int      `json:"chapters"`
	Demographics   *[]MalUrl `json:"demographics,omitempty"`
	ExplicitGenres *[]MalUrl `json:"explicit_genres,omitempty"`
	External       *[]struct {
		Name *string `json:"name,omitempty"`
		Url  *string `json:"url,omitempty"`
	} `json:"external,omitempty"`

	// Favorites Number of users who have favorited this entry
	Favorites *int         `json:"favorites"`
	Genres    *[]MalUrl    `json:"genres,omitempty"`
	Images    *MangaImages `json:"images,omitempty"`

	// MalId MyAnimeList ID
	MalId *int `json:"mal_id,omitempty"`

	// Members Number of users who have added this entry to their list
	Members *int `json:"members"`

	// Popularity Popularity
	Popularity *int `json:"popularity"`

	// Published Date range
	Published *Daterange `json:"published,omitempty"`

	// Publishing Publishing boolean
	Publishing *bool `json:"publishing,omitempty"`

	// Rank Ranking
	Rank      *int `json:"rank"`
	Relations *[]struct {
		Entry *[]MalUrl `json:"entry,omitempty"`

		// Relation Relation type
		Relation *string `json:"relation,omitempty"`
	} `json:"relations,omitempty"`

	// Score Score
	Score *float32 `json:"score"`

	// ScoredBy Number of users
	ScoredBy       *int      `json:"scored_by"`
	Serializations *[]MalUrl `json:"serializations,omitempty"`

	// Status Publishing status
	Status *MangaFullStatus `json:"status,omitempty"`

	// Synopsis Synopsis
	Synopsis *string   `json:"synopsis"`
	Themes   *[]MalUrl `json:"themes,omitempty"`

	// Title Title
	// Deprecated:
	Title *string `json:"title,omitempty"`

	// TitleEnglish English Title
	// Deprecated:
	TitleEnglish *string `json:"title_english"`

	// TitleJapanese Japanese Title
	// Deprecated:
	TitleJapanese *string `json:"title_japanese"`

	// TitleSynonyms Other Titles
	// Deprecated:
	TitleSynonyms *[]string `json:"title_synonyms,omitempty"`

	// Titles All Titles
	Titles *[]Title `json:"titles,omitempty"`

	// Type Manga Type
	Type *MangaFullType `json:"type"`

	// Url MyAnimeList URL
	Url *string `json:"url,omitempty"`

	// Volumes Volume count
	Volumes *int `json:"volumes"`
}

// MangaFullStatus Publishing status
type MangaFullStatus string

// MangaFullType Manga Type
type MangaFullType string

// MangaImages defines model for manga_images.
type MangaImages struct {
	// Jpg Available images in JPG
	Jpg *struct {
		// ImageUrl Image URL JPG
		ImageUrl *string `json:"image_url"`

		// LargeImageUrl Image URL JPG
		LargeImageUrl *string `json:"large_image_url"`

		// SmallImageUrl Small Image URL JPG
		SmallImageUrl *string `json:"small_image_url"`
	} `json:"jpg,omitempty"`

	// Webp Available images in WEBP
	Webp *struct {
		// ImageUrl Image URL WEBP
		ImageUrl *string `json:"image_url"`

		// LargeImageUrl Image URL WEBP
		LargeImageUrl *string `json:"large_image_url"`

		// SmallImageUrl Small Image URL WEBP
		SmallImageUrl *string `json:"small_image_url"`
	} `json:"webp,omitempty"`
}

// MangaMeta defines model for manga_meta.
type MangaMeta struct {
	Images *MangaImages `json:"images,omitempty"`

	// MalId MyAnimeList ID
	MalId *int `json:"mal_id,omitempty"`

	// Title Entry title
	Title *string `json:"title,omitempty"`

	// Url MyAnimeList URL
	Url *string `json:"url,omitempty"`
}

// MangaNews defines model for manga_news.
type MangaNews struct {
	Data *[]struct {
		// AuthorUrl Author Profile URL
		AuthorUrl *string `json:"author_url,omitempty"`

		// AuthorUsername Author MyAnimeList Username
		AuthorUsername *string `json:"author_username,omitempty"`

		// Comments Comment count
		Comments *int `json:"comments,omitempty"`

		// Date Post Date ISO8601
		Date *string `json:"date,omitempty"`

		// Excerpt Excerpt
		Excerpt *string `json:"excerpt,omitempty"`

		// ForumUrl Forum topic URL
		ForumUrl *string       `json:"forum_url,omitempty"`
		Images   *CommonImages `json:"images,omitempty"`

		// MalId MyAnimeList ID
		MalId *int `json:"mal_id,omitempty"`

		// Title Title
		Title *string `json:"title,omitempty"`

		// Url MyAnimeList URL
		Url *string `json:"url,omitempty"`
	} `json:"data,omitempty"`
	Pagination *struct {
		HasNextPage     *bool `json:"has_next_page,omitempty"`
		LastVisiblePage *int  `json:"last_visible_page,omitempty"`
	} `json:"pagination,omitempty"`
}

// MangaPictures Manga Pictures
type MangaPictures struct {
	Data *[]MangaImages `json:"data,omitempty"`
}

// MangaReview defines model for manga_review.
type MangaReview struct {
	// Date Review created date ISO8601
	Date *string `json:"date,omitempty"`

	// IsPreliminary The review was made before the entry was completed
	IsPreliminary *bool `json:"is_preliminary,omitempty"`

	// IsSpoiler The review contains spoiler
	IsSpoiler *bool `json:"is_spoiler,omitempty"`

	// MalId MyAnimeList ID
	MalId *int `json:"mal_id,omitempty"`

	// Reactions User reaction count on the review
	Reactions *struct {
		// Confusing Confusing reaction count
		Confusing *int `json:"confusing,omitempty"`

		// Creative Creative reaction count
		Creative *int `json:"creative,omitempty"`

		// Funny Funny reaction count
		Funny *int `json:"funny,omitempty"`

		// Informative Informative reaction count
		Informative *int `json:"informative,omitempty"`

		// LoveIt Love it reaction count
		LoveIt *int `json:"love_it,omitempty"`

		// Nice Nice reaction count
		Nice *int `json:"nice,omitempty"`

		// Overall Overall reaction count
		Overall *int `json:"overall,omitempty"`

		// WellWritten Well written reaction count
		WellWritten *int `json:"well_written,omitempty"`
	} `json:"reactions,omitempty"`

	// Review Review content
	Review *string `json:"review,omitempty"`

	// Score Number of user votes on the Review
	Score *int `json:"score,omitempty"`

	// Tags Review tags
	Tags *[]string `json:"tags,omitempty"`

	// Type Entry type
	Type *string `json:"type,omitempty"`

	// Url MyAnimeList review URL
	Url *string `json:"url,omitempty"`
}

// MangaReviews defines model for manga_reviews.
type MangaReviews struct {
	Data *[]struct {
		// Date Review created date ISO8601
		Date *string `json:"date,omitempty"`

		// IsPreliminary The review was made before the entry was completed
		IsPreliminary *bool `json:"is_preliminary,omitempty"`

		// IsSpoiler The review contains spoiler
		IsSpoiler *bool `json:"is_spoiler,omitempty"`

		// MalId MyAnimeList ID
		MalId *int `json:"mal_id,omitempty"`

		// Reactions User reaction count on the review
		Reactions *struct {
			// Confusing Confusing reaction count
			Confusing *int `json:"confusing,omitempty"`

			// Creative Creative reaction count
			Creative *int `json:"creative,omitempty"`

			// Funny Funny reaction count
			Funny *int `json:"funny,omitempty"`

			// Informative Informative reaction count
			Informative *int `json:"informative,omitempty"`

			// LoveIt Love it reaction count
			LoveIt *int `json:"love_it,omitempty"`

			// Nice Nice reaction count
			Nice *int `json:"nice,omitempty"`

			// Overall Overall reaction count
			Overall *int `json:"overall,omitempty"`

			// WellWritten Well written reaction count
			WellWritten *int `json:"well_written,omitempty"`
		} `json:"reactions,omitempty"`

		// Review Review content
		Review *string `json:"review,omitempty"`

		// Score Number of user votes on the Review
		Score *int `json:"score,omitempty"`

		// Tags Review tags
		Tags *[]string `json:"tags,omitempty"`

		// Type Entry type
		Type *string `json:"type,omitempty"`

		// Url MyAnimeList review URL
		Url  *string   `json:"url,omitempty"`
		User *UserMeta `json:"user,omitempty"`
	} `json:"data,omitempty"`
	Pagination *struct {
		HasNextPage     *bool `json:"has_next_page,omitempty"`
		LastVisiblePage *int  `json:"last_visible_page,omitempty"`
	} `json:"pagination,omitempty"`
}

// MangaSearch defines model for manga_search.
type MangaSearch struct {
	Data       *[]Manga `json:"data,omitempty"`
	Pagination *struct {
		HasNextPage *bool `json:"has_next_page,omitempty"`
		Items       *struct {
			Count   *int `json:"count,omitempty"`
			PerPage *int `json:"per_page,omitempty"`
			Total   *int `json:"total,omitempty"`
		} `json:"items,omitempty"`
		LastVisiblePage *int `json:"last_visible_page,omitempty"`
	} `json:"pagination,omitempty"`
}

// MangaSearchQueryOrderby Available Manga order_by properties
type MangaSearchQueryOrderby string

// MangaSearchQueryStatus Available Manga statuses
type MangaSearchQueryStatus string

// MangaSearchQueryType Available Manga types
type MangaSearchQueryType string

// MangaStatistics Manga Statistics Resource
type MangaStatistics struct {
	Data *struct {
		// Completed Number of users who have completed the resource
		Completed *int `json:"completed,omitempty"`

		// Dropped Number of users who have dropped the resource
		Dropped *int `json:"dropped,omitempty"`

		// OnHold Number of users who have put the resource on hold
		OnHold *int `json:"on_hold,omitempty"`

		// PlanToRead Number of users who have planned to read the resource
		PlanToRead *int `json:"plan_to_read,omitempty"`

		// Reading Number of users reading the resource
		Reading *int `json:"reading,omitempty"`
		Scores  *[]struct {
			// Percentage Percentage of votes for this score
			Percentage *float32 `json:"percentage,omitempty"`

			// Score Scoring value
			Score *int `json:"score,omitempty"`

			// Votes Number of votes for this score
			Votes *int `json:"votes,omitempty"`
		} `json:"scores,omitempty"`

		// Total Total number of users who have the resource added to their lists
		Total *int `json:"total,omitempty"`
	} `json:"data,omitempty"`
}

// MangaUserupdates defines model for manga_userupdates.
type MangaUserupdates struct {
	Data *[]struct {
		// ChaptersRead Number of chapters read
		ChaptersRead *int `json:"chapters_read,omitempty"`

		// ChaptersTotal Total number of chapters
		ChaptersTotal *int `json:"chapters_total,omitempty"`

		// Date Last updated date ISO8601
		Date *string `json:"date,omitempty"`

		// Score User Score
		Score *int `json:"score"`

		// Status User list status
		Status *string   `json:"status,omitempty"`
		User   *UserMeta `json:"user,omitempty"`

		// VolumesRead Number of volumes read
		VolumesRead *int `json:"volumes_read,omitempty"`

		// VolumesTotal Total number of volumes
		VolumesTotal *int `json:"volumes_total,omitempty"`
	} `json:"data,omitempty"`
	Pagination *struct {
		HasNextPage     *bool `json:"has_next_page,omitempty"`
		LastVisiblePage *int  `json:"last_visible_page,omitempty"`
	} `json:"pagination,omitempty"`
}

// Moreinfo More Info Resource
type Moreinfo struct {
	Data *struct {
		// Moreinfo Additional information on the entry
		Moreinfo *string `json:"moreinfo"`
	} `json:"data,omitempty"`
}

// News defines model for news.
type News struct {
	Data *[]struct {
		// AuthorUrl Author Profile URL
		AuthorUrl *string `json:"author_url,omitempty"`

		// AuthorUsername Author MyAnimeList Username
		AuthorUsername *string `json:"author_username,omitempty"`

		// Comments Comment count
		Comments *int `json:"comments,omitempty"`

		// Date Post Date ISO8601
		Date *string `json:"date,omitempty"`

		// Excerpt Excerpt
		Excerpt *string `json:"excerpt,omitempty"`

		// ForumUrl Forum topic URL
		ForumUrl *string       `json:"forum_url,omitempty"`
		Images   *CommonImages `json:"images,omitempty"`

		// MalId MyAnimeList ID
		MalId *int `json:"mal_id,omitempty"`

		// Title Title
		Title *string `json:"title,omitempty"`

		// Url MyAnimeList URL
		Url *string `json:"url,omitempty"`
	} `json:"data,omitempty"`
}

// Pagination defines model for pagination.
type Pagination struct {
	Pagination *struct {
		HasNextPage     *bool `json:"has_next_page,omitempty"`
		LastVisiblePage *int  `json:"last_visible_page,omitempty"`
	} `json:"pagination,omitempty"`
}

// PaginationPlus defines model for pagination_plus.
type PaginationPlus struct {
	Pagination *struct {
		HasNextPage *bool `json:"has_next_page,omitempty"`
		Items       *struct {
			Count   *int `json:"count,omitempty"`
			PerPage *int `json:"per_page,omitempty"`
			Total   *int `json:"total,omitempty"`
		} `json:"items,omitempty"`
		LastVisiblePage *int `json:"last_visible_page,omitempty"`
	} `json:"pagination,omitempty"`
}

// PeopleImages defines model for people_images.
type PeopleImages struct {
	// Jpg Available images in JPG
	Jpg *struct {
		// ImageUrl Image URL JPG
		ImageUrl *string `json:"image_url"`
	} `json:"jpg,omitempty"`
}

// PeopleSearch defines model for people_search.
type PeopleSearch struct {
	Data       *[]Person `json:"data,omitempty"`
	Pagination *struct {
		HasNextPage *bool `json:"has_next_page,omitempty"`
		Items       *struct {
			Count   *int `json:"count,omitempty"`
			PerPage *int `json:"per_page,omitempty"`
			Total   *int `json:"total,omitempty"`
		} `json:"items,omitempty"`
		LastVisiblePage *int `json:"last_visible_page,omitempty"`
	} `json:"pagination,omitempty"`
}

// PeopleSearchQueryOrderby Available People order_by properties
type PeopleSearchQueryOrderby string

// Person Person Resource
type Person struct {
	// About Biography
	About *string `json:"about"`

	// AlternateNames Other Names
	AlternateNames *[]string `json:"alternate_names,omitempty"`

	// Birthday Birthday Date ISO8601
	Birthday *string `json:"birthday"`

	// FamilyName Family Name
	FamilyName *string `json:"family_name"`

	// Favorites Number of users who have favorited this entry
	Favorites *int `json:"favorites,omitempty"`

	// GivenName Given Name
	GivenName *string       `json:"given_name"`
	Images    *PeopleImages `json:"images,omitempty"`

	// MalId MyAnimeList ID
	MalId *int `json:"mal_id,omitempty"`

	// Name Name
	Name *string `json:"name,omitempty"`

	// Url MyAnimeList URL
	Url *string `json:"url,omitempty"`

	// WebsiteUrl Person's website URL
	WebsiteUrl *string `json:"website_url"`
}

// PersonAnime Person anime staff positions
type PersonAnime struct {
	Data *[]struct {
		Anime *AnimeMeta `json:"anime,omitempty"`

		// Position Person's position
		Position *string `json:"position,omitempty"`
	} `json:"data,omitempty"`
}

// PersonFull Person Resource
type PersonFull struct {
	// About Biography
	About *string `json:"about"`

	// AlternateNames Other Names
	AlternateNames *[]string `json:"alternate_names,omitempty"`
	Anime          *[]struct {
		Anime *AnimeMeta `json:"anime,omitempty"`

		// Position Person's position
		Position *string `json:"position,omitempty"`
	} `json:"anime,omitempty"`

	// Birthday Birthday Date ISO8601
	Birthday *string `json:"birthday"`

	// FamilyName Family Name
	FamilyName *string `json:"family_name"`

	// Favorites Number of users who have favorited this entry
	Favorites *int `json:"favorites,omitempty"`

	// GivenName Given Name
	GivenName *string       `json:"given_name"`
	Images    *PeopleImages `json:"images,omitempty"`

	// MalId MyAnimeList ID
	MalId *int `json:"mal_id,omitempty"`
	Manga *[]struct {
		Manga *MangaMeta `json:"manga,omitempty"`

		// Position Person's position
		Position *string `json:"position,omitempty"`
	} `json:"manga,omitempty"`

	// Name Name
	Name *string `json:"name,omitempty"`

	// Url MyAnimeList URL
	Url    *string `json:"url,omitempty"`
	Voices *[]struct {
		Anime     *AnimeMeta     `json:"anime,omitempty"`
		Character *CharacterMeta `json:"character,omitempty"`

		// Role Person's Character's role in the anime
		Role *string `json:"role,omitempty"`
	} `json:"voices,omitempty"`

	// WebsiteUrl Person's website URL
	WebsiteUrl *string `json:"website_url"`
}

// PersonManga Person's mangaography
type PersonManga struct {
	Data *[]struct {
		Manga *MangaMeta `json:"manga,omitempty"`

		// Position Person's position
		Position *string `json:"position,omitempty"`
	} `json:"data,omitempty"`
}

// PersonMeta defines model for person_meta.
type PersonMeta struct {
	Images *PeopleImages `json:"images,omitempty"`

	// MalId MyAnimeList ID
	MalId *int `json:"mal_id,omitempty"`

	// Name Entry name
	Name *string `json:"name,omitempty"`

	// Url MyAnimeList URL
	Url *string `json:"url,omitempty"`
}

// PersonPictures Character Pictures
type PersonPictures struct {
	Data *[]PeopleImages `json:"data,omitempty"`
}

// PersonVoiceActingRoles Person's voice acting roles
type PersonVoiceActingRoles struct {
	Data *[]struct {
		Anime     *AnimeMeta     `json:"anime,omitempty"`
		Character *CharacterMeta `json:"character,omitempty"`

		// Role Person's Character's role in the anime
		Role *string `json:"role,omitempty"`
	} `json:"data,omitempty"`
}

// Pictures Pictures Resource
type Pictures struct {
	Data *[]struct {
		Images *AnimeImages `json:"images,omitempty"`
	} `json:"data,omitempty"`
}

// PicturesVariants Pictures Resource
type PicturesVariants struct {
	Data *[]struct {
		Images *CommonImages `json:"images,omitempty"`
	} `json:"data,omitempty"`
}

// Producer Producers Resource
type Producer struct {
	// About About the Producer
	About *string `json:"about"`

	// Count Producers's anime count
	Count *int `json:"count,omitempty"`

	// Established Established Date ISO8601
	Established *string `json:"established"`

	// Favorites Producers's member favorites count
	Favorites *int          `json:"favorites,omitempty"`
	Images    *CommonImages `json:"images,omitempty"`

	// MalId MyAnimeList ID
	MalId *int `json:"mal_id,omitempty"`

	// Titles All titles
	Titles *[]Title `json:"titles,omitempty"`

	// Url MyAnimeList URL
	Url *string `json:"url,omitempty"`
}

// ProducerFull Producers Resource
type ProducerFull struct {
	// About About the Producer
	About *string `json:"about"`

	// Count Producers's anime count
	Count *int `json:"count,omitempty"`

	// Established Established Date ISO8601
	Established *string `json:"established"`
	External    *[]struct {
		Name *string `json:"name,omitempty"`
		Url  *string `json:"url,omitempty"`
	} `json:"external,omitempty"`

	// Favorites Producers's member favorites count
	Favorites *int          `json:"favorites,omitempty"`
	Images    *CommonImages `json:"images,omitempty"`

	// MalId MyAnimeList ID
	MalId *int `json:"mal_id,omitempty"`

	// Titles All titles
	Titles *[]Title `json:"titles,omitempty"`

	// Url MyAnimeList URL
	Url *string `json:"url,omitempty"`
}

// Producers defines model for producers.
type Producers struct {
	Data       *[]Producer `json:"data,omitempty"`
	Pagination *struct {
		HasNextPage     *bool `json:"has_next_page,omitempty"`
		LastVisiblePage *int  `json:"last_visible_page,omitempty"`
	} `json:"pagination,omitempty"`
}

// ProducersQueryOrderby Producers Search Query Order By
type ProducersQueryOrderby string

// Random Random Resources
type Random struct {
	Data *[]Random_Data_Item `json:"data,omitempty"`
}

// Random_Data_Item defines model for random.data.Item.
type Random_Data_Item struct {
	union json.RawMessage
}

// Recommendations defines model for recommendations.
type Recommendations struct {
	Data *[]struct {
		// Content Recommendation context provided by the user
		Content *string `json:"content,omitempty"`

		// Entry Array of 2 entries that are being recommended to each other
		Entry *[]Recommendations_Data_Entry_Item `json:"entry,omitempty"`

		// MalId MAL IDs of recommendations is both of the MAL ID's with a `-` delimiter
		MalId *string `json:"mal_id,omitempty"`

		// User User Meta By ID
		User *UserById `json:"user,omitempty"`
	} `json:"data,omitempty"`
	Pagination *struct {
		HasNextPage     *bool `json:"has_next_page,omitempty"`
		LastVisiblePage *int  `json:"last_visible_page,omitempty"`
	} `json:"pagination,omitempty"`
}

// Recommendations_Data_Entry_Item defines model for Recommendations.Data.Entry.Item.
type Recommendations_Data_Entry_Item struct {
	union json.RawMessage
}

// Relation Related resources
type Relation struct {
	// Entry Related entries
	Entry *[]MalUrl `json:"entry,omitempty"`

	// Relation Relation type
	Relation *string `json:"relation,omitempty"`
}

// ReviewsCollection Anime & Manga Reviews Resource
type ReviewsCollection struct {
	Data *[]ReviewsCollection_Data_Item `json:"data,omitempty"`
}

// ReviewsCollection_Data_Item defines model for reviews_collection.data.Item.
type ReviewsCollection_Data_Item struct {
	union json.RawMessage
}

// Schedules defines model for schedules.
type Schedules struct {
	Data       *[]Anime `json:"data,omitempty"`
	Pagination *struct {
		HasNextPage *bool `json:"has_next_page,omitempty"`
		Items       *struct {
			Count   *int `json:"count,omitempty"`
			PerPage *int `json:"per_page,omitempty"`
			Total   *int `json:"total,omitempty"`
		} `json:"items,omitempty"`
		LastVisiblePage *int `json:"last_visible_page,omitempty"`
	} `json:"pagination,omitempty"`
}

// SearchQuerySort Search query sort direction
type SearchQuerySort string

// Seasons List of available seasons
type Seasons struct {
	Data *[]struct {
		// Seasons List of available seasons
		Seasons *[]string `json:"seasons,omitempty"`

		// Year Year
		Year *int `json:"year,omitempty"`
	} `json:"data,omitempty"`
}

// StreamingLinks Streaming links
type StreamingLinks struct {
	Data *[]struct {
		Name *string `json:"name,omitempty"`
		Url  *string `json:"url,omitempty"`
	} `json:"data,omitempty"`
}

// Title defines model for title.
type Title struct {
	// Title Title value
	Title *string `json:"title,omitempty"`

	// Type Title type
	Type *string `json:"type,omitempty"`
}

// TopAnimeFilter Top items filter types
type TopAnimeFilter string

// TopMangaFilter Top items filter types
type TopMangaFilter string

// TopReviewsTypeEnum The type of reviews to filter by. Defaults to anime.
type TopReviewsTypeEnum string

// Trailer defines model for trailer.
type Trailer struct {
	// EmbedUrl Parsed Embed URL
	EmbedUrl *string `json:"embed_url"`
	Images   *struct {
		// ImageUrl Default Image Size URL (120x90)
		ImageUrl *string `json:"image_url"`

		// LargeImageUrl Large Image Size URL (480x360)
		LargeImageUrl *string `json:"large_image_url"`

		// MaximumImageUrl Maximum Image Size URL (1280x720)
		MaximumImageUrl *string `json:"maximum_image_url"`

		// MediumImageUrl Medium Image Size URL (320x180)
		MediumImageUrl *string `json:"medium_image_url"`

		// SmallImageUrl Small Image Size URL (640x480)
		SmallImageUrl *string `json:"small_image_url"`
	} `json:"images,omitempty"`

	// Url YouTube URL
	Url *string `json:"url"`

	// YoutubeId YouTube ID
	YoutubeId *string `json:"youtube_id"`
}

// TrailerBase Youtube Details
type TrailerBase struct {
	// EmbedUrl Parsed Embed URL
	EmbedUrl *string `json:"embed_url"`

	// Url YouTube URL
	Url *string `json:"url"`

	// YoutubeId YouTube ID
	YoutubeId *string `json:"youtube_id"`
}

// TrailerImages Youtube Images
type TrailerImages struct {
	Images *struct {
		// ImageUrl Default Image Size URL (120x90)
		ImageUrl *string `json:"image_url"`

		// LargeImageUrl Large Image Size URL (480x360)
		LargeImageUrl *string `json:"large_image_url"`

		// MaximumImageUrl Maximum Image Size URL (1280x720)
		MaximumImageUrl *string `json:"maximum_image_url"`

		// MediumImageUrl Medium Image Size URL (320x180)
		MediumImageUrl *string `json:"medium_image_url"`

		// SmallImageUrl Small Image Size URL (640x480)
		SmallImageUrl *string `json:"small_image_url"`
	} `json:"images,omitempty"`
}

// UserAbout defines model for user_about.
type UserAbout struct {
	Data *[]struct {
		// About User About. NOTE: About information is customizable by users through BBCode on MyAnimeList. This means users can add multimedia content, different text sizes, etc. Due to this freeform, Jikan returns parsed HTML. Validate on your end!
		About *string `json:"about"`
	} `json:"data,omitempty"`
}

// UserAnimeListStatusFilter User's anime list status filter options
type UserAnimeListStatusFilter string

// UserById User Meta By ID
type UserById struct {
	// Url MyAnimeList URL
	Url *string `json:"url,omitempty"`

	// Username MyAnimeList Username
	Username *string `json:"username,omitempty"`
}

// UserClubs defines model for user_clubs.
type UserClubs struct {
	Data *[]struct {
		// MalId MyAnimeList ID
		MalId *int `json:"mal_id,omitempty"`

		// Name Club Name
		Name *string `json:"name,omitempty"`

		// Url Club URL
		Url *string `json:"url,omitempty"`
	} `json:"data,omitempty"`
	Pagination *struct {
		HasNextPage     *bool `json:"has_next_page,omitempty"`
		LastVisiblePage *int  `json:"last_visible_page,omitempty"`
	} `json:"pagination,omitempty"`
}

// UserFavorites defines model for user_favorites.
type UserFavorites struct {
	// Anime Favorite Anime
	Anime *[]struct {
		Images *AnimeImages `json:"images,omitempty"`

		// MalId MyAnimeList ID
		MalId     *int `json:"mal_id,omitempty"`
		StartYear *int `json:"start_year,omitempty"`

		// Title Entry title
		Title *string `json:"title,omitempty"`
		Type  *string `json:"type,omitempty"`

		// Url MyAnimeList URL
		Url *string `json:"url,omitempty"`
	} `json:"anime,omitempty"`

	// Characters Favorite Characters
	Characters *[]struct {
		Images *CharacterImages `json:"images,omitempty"`

		// MalId MyAnimeList ID
		MalId *int `json:"mal_id,omitempty"`

		// Name Entry name
		Name *string `json:"name,omitempty"`

		// Title Resource Name/Title
		Title *string `json:"title,omitempty"`

		// Type Type of resource
		Type *string `json:"type,omitempty"`

		// Url MyAnimeList URL
		Url *string `json:"url,omitempty"`
	} `json:"characters,omitempty"`

	// Manga Favorite Manga
	Manga *[]struct {
		Images *MangaImages `json:"images,omitempty"`

		// MalId MyAnimeList ID
		MalId     *int `json:"mal_id,omitempty"`
		StartYear *int `json:"start_year,omitempty"`

		// Title Entry title
		Title *string `json:"title,omitempty"`
		Type  *string `json:"type,omitempty"`

		// Url MyAnimeList URL
		Url *string `json:"url,omitempty"`
	} `json:"manga,omitempty"`

	// People Favorite People
	People *[]CharacterMeta `json:"people,omitempty"`
}

// UserFriends defines model for user_friends.
type UserFriends struct {
	Data *[]struct {
		// FriendsSince Friends Since Date ISO8601 format
		FriendsSince *string `json:"friends_since,omitempty"`

		// LastOnline Last Online Date ISO8601 format
		LastOnline *string   `json:"last_online,omitempty"`
		User       *UserMeta `json:"user,omitempty"`
	} `json:"data,omitempty"`
	Pagination *struct {
		HasNextPage     *bool `json:"has_next_page,omitempty"`
		LastVisiblePage *int  `json:"last_visible_page,omitempty"`
	} `json:"pagination,omitempty"`
}

// UserHistory defines model for user_history.
type UserHistory struct {
	Data *[]History `json:"data,omitempty"`
}

// UserImages defines model for user_images.
type UserImages struct {
	// Jpg Available images in JPG
	Jpg *struct {
		// ImageUrl Image URL JPG
		ImageUrl *string `json:"image_url"`
	} `json:"jpg,omitempty"`

	// Webp Available images in WEBP
	Webp *struct {
		// ImageUrl Image URL WEBP
		ImageUrl *string `json:"image_url"`
	} `json:"webp,omitempty"`
}

// UserMangaListStatusFilter User's anime list status filter options
type UserMangaListStatusFilter string

// UserMeta defines model for user_meta.
type UserMeta struct {
	Images *UserImages `json:"images,omitempty"`

	// Url MyAnimeList Profile URL
	Url *string `json:"url,omitempty"`

	// Username MyAnimeList Username
	Username *string `json:"username,omitempty"`
}

// UserProfile defines model for user_profile.
type UserProfile struct {
	// Birthday Birthday Date ISO8601
	Birthday *string `json:"birthday"`

	// Gender User Gender
	Gender *string     `json:"gender"`
	Images *UserImages `json:"images,omitempty"`

	// Joined Joined Date ISO8601
	Joined *string `json:"joined"`

	// LastOnline Last Online Date ISO8601
	LastOnline *string `json:"last_online"`

	// Location Location
	Location *string `json:"location"`

	// MalId MyAnimeList ID
	MalId *int `json:"mal_id"`

	// Url MyAnimeList URL
	Url *string `json:"url,omitempty"`

	// Username MyAnimeList Username
	Username *string `json:"username,omitempty"`
}

// UserProfileFull Transform the resource into an array.
type UserProfileFull struct {
	// Birthday Birthday Date ISO8601
	Birthday *string `json:"birthday"`
	External *[]struct {
		Name *string `json:"name,omitempty"`
		Url  *string `json:"url,omitempty"`
	} `json:"external,omitempty"`

	// Gender User Gender
	Gender *string     `json:"gender"`
	Images *UserImages `json:"images,omitempty"`

	// Joined Joined Date ISO8601
	Joined *string `json:"joined"`

	// LastOnline Last Online Date ISO8601
	LastOnline *string `json:"last_online"`

	// Location Location
	Location *string `json:"location"`

	// MalId MyAnimeList ID
	MalId      *int `json:"mal_id"`
	Statistics *struct {
		// Anime Anime Statistics
		Anime *struct {
			// Completed Anime Completed
			Completed *int `json:"completed,omitempty"`

			// DaysWatched Number of days spent watching Anime
			DaysWatched *float32 `json:"days_watched,omitempty"`

			// Dropped Anime Dropped
			Dropped *int `json:"dropped,omitempty"`

			// EpisodesWatched Number of Anime Episodes Watched
			EpisodesWatched *int `json:"episodes_watched,omitempty"`

			// MeanScore Mean Score
			MeanScore *float32 `json:"mean_score,omitempty"`

			// OnHold Anime On-Hold
			OnHold *int `json:"on_hold,omitempty"`

			// PlanToWatch Anime Planned to Watch
			PlanToWatch *int `json:"plan_to_watch,omitempty"`

			// Rewatched Anime re-watched
			Rewatched *int `json:"rewatched,omitempty"`

			// TotalEntries Total Anime entries on User list
			TotalEntries *int `json:"total_entries,omitempty"`

			// Watching Anime Watching
			Watching *int `json:"watching,omitempty"`
		} `json:"anime,omitempty"`

		// Manga Manga Statistics
		Manga *struct {
			// ChaptersRead Number of Manga Chapters Read
			ChaptersRead *int `json:"chapters_read,omitempty"`

			// Completed Manga Completed
			Completed *int `json:"completed,omitempty"`

			// DaysRead Number of days spent reading Manga
			DaysRead *float32 `json:"days_read,omitempty"`

			// Dropped Manga Dropped
			Dropped *int `json:"dropped,omitempty"`

			// MeanScore Mean Score
			MeanScore *float32 `json:"mean_score,omitempty"`

			// OnHold Manga On-Hold
			OnHold *int `json:"on_hold,omitempty"`

			// PlanToRead Manga Planned to Read
			PlanToRead *int `json:"plan_to_read,omitempty"`

			// Reading Manga Reading
			Reading *int `json:"reading,omitempty"`

			// Reread Manga re-read
			Reread *int `json:"reread,omitempty"`

			// TotalEntries Total Manga entries on User list
			TotalEntries *int `json:"total_entries,omitempty"`

			// VolumesRead Number of Manga Volumes Read
			VolumesRead *int `json:"volumes_read,omitempty"`
		} `json:"manga,omitempty"`
	} `json:"statistics,omitempty"`

	// Url MyAnimeList URL
	Url *string `json:"url,omitempty"`

	// Username MyAnimeList Username
	Username *string `json:"username,omitempty"`
}

// UserStatistics defines model for user_statistics.
type UserStatistics struct {
	Data *struct {
		// Anime Anime Statistics
		Anime *struct {
			// Completed Anime Completed
			Completed *int `json:"completed,omitempty"`

			// DaysWatched Number of days spent watching Anime
			DaysWatched *float32 `json:"days_watched,omitempty"`

			// Dropped Anime Dropped
			Dropped *int `json:"dropped,omitempty"`

			// EpisodesWatched Number of Anime Episodes Watched
			EpisodesWatched *int `json:"episodes_watched,omitempty"`

			// MeanScore Mean Score
			MeanScore *float32 `json:"mean_score,omitempty"`

			// OnHold Anime On-Hold
			OnHold *int `json:"on_hold,omitempty"`

			// PlanToWatch Anime Planned to Watch
			PlanToWatch *int `json:"plan_to_watch,omitempty"`

			// Rewatched Anime re-watched
			Rewatched *int `json:"rewatched,omitempty"`

			// TotalEntries Total Anime entries on User list
			TotalEntries *int `json:"total_entries,omitempty"`

			// Watching Anime Watching
			Watching *int `json:"watching,omitempty"`
		} `json:"anime,omitempty"`

		// Manga Manga Statistics
		Manga *struct {
			// ChaptersRead Number of Manga Chapters Read
			ChaptersRead *int `json:"chapters_read,omitempty"`

			// Completed Manga Completed
			Completed *int `json:"completed,omitempty"`

			// DaysRead Number of days spent reading Manga
			DaysRead *float32 `json:"days_read,omitempty"`

			// Dropped Manga Dropped
			Dropped *int `json:"dropped,omitempty"`

			// MeanScore Mean Score
			MeanScore *float32 `json:"mean_score,omitempty"`

			// OnHold Manga On-Hold
			OnHold *int `json:"on_hold,omitempty"`

			// PlanToRead Manga Planned to Read
			PlanToRead *int `json:"plan_to_read,omitempty"`

			// Reading Manga Reading
			Reading *int `json:"reading,omitempty"`

			// Reread Manga re-read
			Reread *int `json:"reread,omitempty"`

			// TotalEntries Total Manga entries on User list
			TotalEntries *int `json:"total_entries,omitempty"`

			// VolumesRead Number of Manga Volumes Read
			VolumesRead *int `json:"volumes_read,omitempty"`
		} `json:"manga,omitempty"`
	} `json:"data,omitempty"`
}

// UserUpdates defines model for user_updates.
type UserUpdates struct {
	Data *struct {
		// Anime Last updated Anime
		Anime *[]struct {
			// Date ISO8601 format
			Date          *string    `json:"date,omitempty"`
			Entry         *AnimeMeta `json:"entry,omitempty"`
			EpisodesSeen  *int       `json:"episodes_seen"`
			EpisodesTotal *int       `json:"episodes_total"`
			Score         *int       `json:"score"`
			Status        *string    `json:"status,omitempty"`
		} `json:"anime,omitempty"`

		// Manga Last updated Manga
		Manga *[]struct {
			ChaptersRead  *int `json:"chapters_read"`
			ChaptersTotal *int `json:"chapters_total"`

			// Date ISO8601 format
			Date         *string    `json:"date,omitempty"`
			Entry        *MangaMeta `json:"entry,omitempty"`
			Score        *int       `json:"score"`
			Status       *string    `json:"status,omitempty"`
			VolumesRead  *int       `json:"volumes_read"`
			VolumesTotal *int       `json:"volumes_total"`
		} `json:"manga,omitempty"`
	} `json:"data,omitempty"`
}

// UsersSearch defines model for users_search.
type UsersSearch struct {
	Data *[]struct {
		Images *UserImages `json:"images,omitempty"`

		// LastOnline Last Online Date ISO8601
		LastOnline *string `json:"last_online,omitempty"`

		// Url MyAnimeList URL
		Url *string `json:"url,omitempty"`

		// Username MyAnimeList Username
		Username *string `json:"username,omitempty"`
	} `json:"data,omitempty"`
	Pagination *struct {
		HasNextPage     *bool `json:"has_next_page,omitempty"`
		LastVisiblePage *int  `json:"last_visible_page,omitempty"`
	} `json:"pagination,omitempty"`
}

// UsersSearchQueryGender Users Search Query Gender.
type UsersSearchQueryGender string

// UsersTemp Transform the resource into an array.
type UsersTemp struct {
	Data *[]struct {
		// About User About. NOTE: About information is customizable by users through BBCode on MyAnimeList. This means users can add multimedia content, different text sizes, etc. Due to this freeform, Jikan returns parsed HTML. Validate on your end!
		About *string `json:"about,omitempty"`

		// AnimeStats Anime Stats
		AnimeStats *struct {
			// Completed Anime Completed
			Completed *int `json:"completed,omitempty"`

			// DaysWatched Number of days spent watching Anime
			DaysWatched *float32 `json:"days_watched,omitempty"`

			// Dropped Anime Dropped
			Dropped *int `json:"dropped,omitempty"`

			// EpisodesWatched Number of Anime Episodes Watched
			EpisodesWatched *int `json:"episodes_watched,omitempty"`

			// MeanScore Mean Score
			MeanScore *float32 `json:"mean_score,omitempty"`

			// OnHold Anime On-Hold
			OnHold *int `json:"on_hold,omitempty"`

			// PlanToWatch Anime Planned to Watch
			PlanToWatch *int `json:"plan_to_watch,omitempty"`

			// Rewatched Anime re-watched
			Rewatched *int `json:"rewatched,omitempty"`

			// TotalEntries Total Anime entries on User list
			TotalEntries *int `json:"total_entries,omitempty"`

			// Watching Anime Watching
			Watching *int `json:"watching,omitempty"`
		} `json:"anime_stats,omitempty"`

		// Birthday Birthday Date ISO8601
		Birthday *string `json:"birthday,omitempty"`

		// Favorites Favorite entries
		Favorites *struct {
			// Anime Favorite Anime
			Anime *[]EntryMeta `json:"anime,omitempty"`

			// Characters Favorite Characters
			Characters *[]EntryMeta `json:"characters,omitempty"`

			// Manga Favorite Manga
			Manga *[]EntryMeta `json:"manga,omitempty"`

			// People Favorite People
			People *[]EntryMeta `json:"people,omitempty"`
		} `json:"favorites,omitempty"`

		// Gender User Gender
		Gender *string `json:"gender,omitempty"`

		// Images Images
		Images *struct {
			// Jpg Available images in JPG
			Jpg *struct {
				// ImageUrl Image URL JPG (225x335)
				ImageUrl *string `json:"image_url,omitempty"`
			} `json:"jpg,omitempty"`

			// Webp Available images in WEBP
			Webp *struct {
				// ImageUrl Image URL WEBP (225x335)
				ImageUrl *string `json:"image_url,omitempty"`
			} `json:"webp,omitempty"`
		} `json:"images,omitempty"`

		// Joined Joined Date ISO8601
		Joined *string `json:"joined,omitempty"`

		// LastOnline Last Online Date ISO8601
		LastOnline *string `json:"last_online,omitempty"`

		// Location Location
		Location *string `json:"location,omitempty"`

		// MalId MyAnimeList ID
		MalId *int `json:"mal_id,omitempty"`

		// MangaStats Manga Stats
		MangaStats *struct {
			// ChaptersRead Number of Manga Chapters Read
			ChaptersRead *int `json:"chapters_read,omitempty"`

			// Completed Manga Completed
			Completed *int `json:"completed,omitempty"`

			// DaysRead Number of days spent reading Manga
			DaysRead *float32 `json:"days_read,omitempty"`

			// Dropped Manga Dropped
			Dropped *int `json:"dropped,omitempty"`

			// MeanScore Mean Score
			MeanScore *float32 `json:"mean_score,omitempty"`

			// OnHold Manga On-Hold
			OnHold *int `json:"on_hold,omitempty"`

			// PlanToRead Manga Planned to Read
			PlanToRead *int `json:"plan_to_read,omitempty"`

			// Reading Manga Reading
			Reading *int `json:"reading,omitempty"`

			// Reread Manga re-read
			Reread *int `json:"reread,omitempty"`

			// TotalEntries Total Manga entries on User list
			TotalEntries *int `json:"total_entries,omitempty"`

			// VolumesRead Number of Manga Volumes Read
			VolumesRead *int `json:"volumes_read,omitempty"`
		} `json:"manga_stats,omitempty"`

		// Url MyAnimeList URL
		Url *string `json:"url,omitempty"`

		// Username MyAnimeList Username
		Username *string `json:"username,omitempty"`
	} `json:"data,omitempty"`
}

// WatchEpisodes defines model for watch_episodes.
type WatchEpisodes struct {
	Data *[]struct {
		Entry *AnimeMeta `json:"entry,omitempty"`

		// Episodes Recent Episodes (max 2 listed)
		Episodes *[]struct {
			// MalId MyAnimeList ID
			MalId *string `json:"mal_id,omitempty"`

			// Premium For MyAnimeList Premium Users
			Premium *bool `json:"premium,omitempty"`

			// Title Episode Title
			Title *string `json:"title,omitempty"`

			// Url MyAnimeList URL
			Url *string `json:"url,omitempty"`
		} `json:"episodes,omitempty"`

		// RegionLocked Region Locked Episode
		RegionLocked *bool `json:"region_locked,omitempty"`
	} `json:"data,omitempty"`
	Pagination *struct {
		HasNextPage     *bool `json:"has_next_page,omitempty"`
		LastVisiblePage *int  `json:"last_visible_page,omitempty"`
	} `json:"pagination,omitempty"`
}

// WatchPromos defines model for watch_promos.
type WatchPromos struct {
	Data *[]struct {
		Entry   *AnimeMeta `json:"entry,omitempty"`
		Trailer *[]Trailer `json:"trailer,omitempty"`
	} `json:"data,omitempty"`
	Pagination *struct {
		HasNextPage     *bool `json:"has_next_page,omitempty"`
		LastVisiblePage *int  `json:"last_visible_page,omitempty"`
	} `json:"pagination,omitempty"`

	// Title Promo Title
	Title *string `json:"title,omitempty"`
}

// Continuing defines model for continuing.
type Continuing = bool

// Kids defines model for kids.
type Kids = bool

// Limit defines model for limit.
type Limit = int

// Page defines model for page.
type Page = int

// Preliminary defines model for preliminary.
type Preliminary = bool

// Sfw defines model for sfw.
type Sfw = bool

// Spoilers defines model for spoilers.
type Spoilers = bool

// Unapproved defines model for unapproved.
type Unapproved = bool

// GetAnimeSearchParams defines parameters for GetAnimeSearch.
type GetAnimeSearchParams struct {
	// Unapproved This is a flag. When supplied it will include entries which are unapproved. Unapproved entries on MyAnimeList are those that are user submitted and have not yet been approved by MAL to show up on other pages. They will have their own specifc pages and are often removed resulting in a 404 error. You do not need to pass a value to it. e.g usage: `?unapproved`
	Unapproved *Unapproved           `form:"unapproved,omitempty" json:"unapproved,omitempty"`
	Page       *Page                 `form:"page,omitempty" json:"page,omitempty"`
	Limit      *Limit                `form:"limit,omitempty" json:"limit,omitempty"`
	Q          *string               `form:"q,omitempty" json:"q,omitempty"`
	Type       *AnimeSearchQueryType `form:"type,omitempty" json:"type,omitempty"`
	Score      *float32              `form:"score,omitempty" json:"score,omitempty"`

	// MinScore Set a minimum score for results.
	MinScore *float32 `form:"min_score,omitempty" json:"min_score,omitempty"`

	// MaxScore Set a maximum score for results
	MaxScore *float32                `form:"max_score,omitempty" json:"max_score,omitempty"`
	Status   *AnimeSearchQueryStatus `form:"status,omitempty" json:"status,omitempty"`
	Rating   *AnimeSearchQueryRating `form:"rating,omitempty" json:"rating,omitempty"`

	// Sfw Filter out Adult entries
	Sfw *bool `form:"sfw,omitempty" json:"sfw,omitempty"`

	// Genres Filter by genre(s) IDs. Can pass multiple with a comma as a delimiter. e.g 1,2,3
	Genres *string `form:"genres,omitempty" json:"genres,omitempty"`

	// GenresExclude Exclude genre(s) IDs. Can pass multiple with a comma as a delimiter. e.g 1,2,3
	GenresExclude *string                  `form:"genres_exclude,omitempty" json:"genres_exclude,omitempty"`
	OrderBy       *AnimeSearchQueryOrderby `form:"order_by,omitempty" json:"order_by,omitempty"`
	Sort          *SearchQuerySort         `form:"sort,omitempty" json:"sort,omitempty"`

	// Letter Return entries starting with the given letter
	Letter *string `form:"letter,omitempty" json:"letter,omitempty"`

	// Producers Filter by producer(s) IDs. Can pass multiple with a comma as a delimiter. e.g 1,2,3
	Producers *string `form:"producers,omitempty" json:"producers,omitempty"`

	// StartDate Filter by starting date. Format: YYYY-MM-DD. e.g `2022`, `2005-05`, `2005-01-01`
	StartDate *string `form:"start_date,omitempty" json:"start_date,omitempty"`

	// EndDate Filter by ending date. Format: YYYY-MM-DD. e.g `2022`, `2005-05`, `2005-01-01`
	EndDate *string `form:"end_date,omitempty" json:"end_date,omitempty"`
}

// GetAnimeEpisodesParams defines parameters for GetAnimeEpisodes.
type GetAnimeEpisodesParams struct {
	Page *Page `form:"page,omitempty" json:"page,omitempty"`
}

// GetAnimeForumParams defines parameters for GetAnimeForum.
type GetAnimeForumParams struct {
	// Filter Filter topics
	Filter *GetAnimeForumParamsFilter `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetAnimeForumParamsFilter defines parameters for GetAnimeForum.
type GetAnimeForumParamsFilter string

// GetAnimeNewsParams defines parameters for GetAnimeNews.
type GetAnimeNewsParams struct {
	Page *Page `form:"page,omitempty" json:"page,omitempty"`
}

// GetAnimeReviewsParams defines parameters for GetAnimeReviews.
type GetAnimeReviewsParams struct {
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Preliminary Any reviews left during an ongoing anime/manga, those reviews are tagged as preliminary. NOTE: Preliminary reviews are not returned by default so if the entry is airing/publishing you need to add this otherwise you will get an empty list. e.g usage: `?preliminary=true`
	Preliminary *Preliminary `form:"preliminary,omitempty" json:"preliminary,omitempty"`

	// Spoilers Any reviews that are tagged as a spoiler. Spoiler reviews are not returned by default. e.g usage: `?spoiler=true`
	Spoilers *Spoilers `form:"spoilers,omitempty" json:"spoilers,omitempty"`
}

// GetAnimeUserUpdatesParams defines parameters for GetAnimeUserUpdates.
type GetAnimeUserUpdatesParams struct {
	Page *Page `form:"page,omitempty" json:"page,omitempty"`
}

// GetAnimeVideosEpisodesParams defines parameters for GetAnimeVideosEpisodes.
type GetAnimeVideosEpisodesParams struct {
	Page *Page `form:"page,omitempty" json:"page,omitempty"`
}

// GetCharactersSearchParams defines parameters for GetCharactersSearch.
type GetCharactersSearchParams struct {
	Page    *Page                         `form:"page,omitempty" json:"page,omitempty"`
	Limit   *Limit                        `form:"limit,omitempty" json:"limit,omitempty"`
	Q       *string                       `form:"q,omitempty" json:"q,omitempty"`
	OrderBy *CharactersSearchQueryOrderby `form:"order_by,omitempty" json:"order_by,omitempty"`
	Sort    *SearchQuerySort              `form:"sort,omitempty" json:"sort,omitempty"`

	// Letter Return entries starting with the given letter
	Letter *string `form:"letter,omitempty" json:"letter,omitempty"`
}

// GetClubsSearchParams defines parameters for GetClubsSearch.
type GetClubsSearchParams struct {
	Page     *Page                    `form:"page,omitempty" json:"page,omitempty"`
	Limit    *Limit                   `form:"limit,omitempty" json:"limit,omitempty"`
	Q        *string                  `form:"q,omitempty" json:"q,omitempty"`
	Type     *ClubSearchQueryType     `form:"type,omitempty" json:"type,omitempty"`
	Category *ClubSearchQueryCategory `form:"category,omitempty" json:"category,omitempty"`
	OrderBy  *ClubSearchQueryOrderby  `form:"order_by,omitempty" json:"order_by,omitempty"`
	Sort     *SearchQuerySort         `form:"sort,omitempty" json:"sort,omitempty"`

	// Letter Return entries starting with the given letter
	Letter *string `form:"letter,omitempty" json:"letter,omitempty"`
}

// GetClubMembersParams defines parameters for GetClubMembers.
type GetClubMembersParams struct {
	Page *Page `form:"page,omitempty" json:"page,omitempty"`
}

// GetAnimeGenresParams defines parameters for GetAnimeGenres.
type GetAnimeGenresParams struct {
	Filter *GenreQueryFilter `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetMangaGenresParams defines parameters for GetMangaGenres.
type GetMangaGenresParams struct {
	Filter *GenreQueryFilter `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetMagazinesParams defines parameters for GetMagazines.
type GetMagazinesParams struct {
	Page    *Page                  `form:"page,omitempty" json:"page,omitempty"`
	Limit   *Limit                 `form:"limit,omitempty" json:"limit,omitempty"`
	Q       *string                `form:"q,omitempty" json:"q,omitempty"`
	OrderBy *MagazinesQueryOrderby `form:"order_by,omitempty" json:"order_by,omitempty"`
	Sort    *SearchQuerySort       `form:"sort,omitempty" json:"sort,omitempty"`

	// Letter Return entries starting with the given letter
	Letter *string `form:"letter,omitempty" json:"letter,omitempty"`
}

// GetMangaSearchParams defines parameters for GetMangaSearch.
type GetMangaSearchParams struct {
	// Unapproved This is a flag. When supplied it will include entries which are unapproved. Unapproved entries on MyAnimeList are those that are user submitted and have not yet been approved by MAL to show up on other pages. They will have their own specifc pages and are often removed resulting in a 404 error. You do not need to pass a value to it. e.g usage: `?unapproved`
	Unapproved *Unapproved           `form:"unapproved,omitempty" json:"unapproved,omitempty"`
	Page       *Page                 `form:"page,omitempty" json:"page,omitempty"`
	Limit      *Limit                `form:"limit,omitempty" json:"limit,omitempty"`
	Q          *string               `form:"q,omitempty" json:"q,omitempty"`
	Type       *MangaSearchQueryType `form:"type,omitempty" json:"type,omitempty"`
	Score      *float32              `form:"score,omitempty" json:"score,omitempty"`

	// MinScore Set a minimum score for results.
	MinScore *float32 `form:"min_score,omitempty" json:"min_score,omitempty"`

	// MaxScore Set a maximum score for results
	MaxScore *float32                `form:"max_score,omitempty" json:"max_score,omitempty"`
	Status   *MangaSearchQueryStatus `form:"status,omitempty" json:"status,omitempty"`

	// Sfw Filter out Adult entries
	Sfw *bool `form:"sfw,omitempty" json:"sfw,omitempty"`

	// Genres Filter by genre(s) IDs. Can pass multiple with a comma as a delimiter. e.g 1,2,3
	Genres *string `form:"genres,omitempty" json:"genres,omitempty"`

	// GenresExclude Exclude genre(s) IDs. Can pass multiple with a comma as a delimiter. e.g 1,2,3
	GenresExclude *string                  `form:"genres_exclude,omitempty" json:"genres_exclude,omitempty"`
	OrderBy       *MangaSearchQueryOrderby `form:"order_by,omitempty" json:"order_by,omitempty"`
	Sort          *SearchQuerySort         `form:"sort,omitempty" json:"sort,omitempty"`

	// Letter Return entries starting with the given letter
	Letter *string `form:"letter,omitempty" json:"letter,omitempty"`

	// Magazines Filter by magazine(s) IDs. Can pass multiple with a comma as a delimiter. e.g 1,2,3
	Magazines *string `form:"magazines,omitempty" json:"magazines,omitempty"`

	// StartDate Filter by starting date. Format: YYYY-MM-DD. e.g `2022`, `2005-05`, `2005-01-01`
	StartDate *string `form:"start_date,omitempty" json:"start_date,omitempty"`

	// EndDate Filter by ending date. Format: YYYY-MM-DD. e.g `2022`, `2005-05`, `2005-01-01`
	EndDate *string `form:"end_date,omitempty" json:"end_date,omitempty"`
}

// GetMangaTopicsParams defines parameters for GetMangaTopics.
type GetMangaTopicsParams struct {
	// Filter Filter topics
	Filter *GetMangaTopicsParamsFilter `form:"filter,omitempty" json:"filter,omitempty"`
}

// GetMangaTopicsParamsFilter defines parameters for GetMangaTopics.
type GetMangaTopicsParamsFilter string

// GetMangaNewsParams defines parameters for GetMangaNews.
type GetMangaNewsParams struct {
	Page *Page `form:"page,omitempty" json:"page,omitempty"`
}

// GetMangaReviewsParams defines parameters for GetMangaReviews.
type GetMangaReviewsParams struct {
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Preliminary Any reviews left during an ongoing anime/manga, those reviews are tagged as preliminary. NOTE: Preliminary reviews are not returned by default so if the entry is airing/publishing you need to add this otherwise you will get an empty list. e.g usage: `?preliminary=true`
	Preliminary *Preliminary `form:"preliminary,omitempty" json:"preliminary,omitempty"`

	// Spoilers Any reviews that are tagged as a spoiler. Spoiler reviews are not returned by default. e.g usage: `?spoiler=true`
	Spoilers *Spoilers `form:"spoilers,omitempty" json:"spoilers,omitempty"`
}

// GetMangaUserUpdatesParams defines parameters for GetMangaUserUpdates.
type GetMangaUserUpdatesParams struct {
	Page *Page `form:"page,omitempty" json:"page,omitempty"`
}

// GetPeopleSearchParams defines parameters for GetPeopleSearch.
type GetPeopleSearchParams struct {
	Page    *Page                     `form:"page,omitempty" json:"page,omitempty"`
	Limit   *Limit                    `form:"limit,omitempty" json:"limit,omitempty"`
	Q       *string                   `form:"q,omitempty" json:"q,omitempty"`
	OrderBy *PeopleSearchQueryOrderby `form:"order_by,omitempty" json:"order_by,omitempty"`
	Sort    *SearchQuerySort          `form:"sort,omitempty" json:"sort,omitempty"`

	// Letter Return entries starting with the given letter
	Letter *string `form:"letter,omitempty" json:"letter,omitempty"`
}

// GetProducersParams defines parameters for GetProducers.
type GetProducersParams struct {
	Page    *Page                  `form:"page,omitempty" json:"page,omitempty"`
	Limit   *Limit                 `form:"limit,omitempty" json:"limit,omitempty"`
	Q       *string                `form:"q,omitempty" json:"q,omitempty"`
	OrderBy *ProducersQueryOrderby `form:"order_by,omitempty" json:"order_by,omitempty"`
	Sort    *SearchQuerySort       `form:"sort,omitempty" json:"sort,omitempty"`

	// Letter Return entries starting with the given letter
	Letter *string `form:"letter,omitempty" json:"letter,omitempty"`
}

// GetRecentAnimeRecommendationsParams defines parameters for GetRecentAnimeRecommendations.
type GetRecentAnimeRecommendationsParams struct {
	Page *Page `form:"page,omitempty" json:"page,omitempty"`
}

// GetRecentMangaRecommendationsParams defines parameters for GetRecentMangaRecommendations.
type GetRecentMangaRecommendationsParams struct {
	Page *Page `form:"page,omitempty" json:"page,omitempty"`
}

// GetRecentAnimeReviewsParams defines parameters for GetRecentAnimeReviews.
type GetRecentAnimeReviewsParams struct {
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Preliminary Any reviews left during an ongoing anime/manga, those reviews are tagged as preliminary. NOTE: Preliminary reviews are not returned by default so if the entry is airing/publishing you need to add this otherwise you will get an empty list. e.g usage: `?preliminary=true`
	Preliminary *Preliminary `form:"preliminary,omitempty" json:"preliminary,omitempty"`

	// Spoilers Any reviews that are tagged as a spoiler. Spoiler reviews are not returned by default. e.g usage: `?spoiler=true`
	Spoilers *Spoilers `form:"spoilers,omitempty" json:"spoilers,omitempty"`
}

// GetRecentMangaReviewsParams defines parameters for GetRecentMangaReviews.
type GetRecentMangaReviewsParams struct {
	Page *Page `form:"page,omitempty" json:"page,omitempty"`

	// Preliminary Any reviews left during an ongoing anime/manga, those reviews are tagged as preliminary. NOTE: Preliminary reviews are not returned by default so if the entry is airing/publishing you need to add this otherwise you will get an empty list. e.g usage: `?preliminary=true`
	Preliminary *Preliminary `form:"preliminary,omitempty" json:"preliminary,omitempty"`

	// Spoilers Any reviews that are tagged as a spoiler. Spoiler reviews are not returned by default. e.g usage: `?spoiler=true`
	Spoilers *Spoilers `form:"spoilers,omitempty" json:"spoilers,omitempty"`
}

// GetSchedulesParams defines parameters for GetSchedules.
type GetSchedulesParams struct {
	// Filter Filter by day
	Filter *GetSchedulesParamsFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// Kids When supplied, it will filter entries with the `Kids` Genre Demographic. When supplied as `kids=true`, it will return only Kid entries and when supplied as `kids=false`, it will filter out any Kid entries. Defaults to `false`.
	Kids *GetSchedulesParamsKids `form:"kids,omitempty" json:"kids,omitempty"`

	// Sfw 'Safe For Work'. When supplied, it will filter entries with the `Hentai` Genre. When supplied as `sfw=true`, it will return only SFW entries and when supplied as `sfw=false`, it will filter out any Hentai entries. Defaults to `false`.
	Sfw *GetSchedulesParamsSfw `form:"sfw,omitempty" json:"sfw,omitempty"`

	// Unapproved This is a flag. When supplied it will include entries which are unapproved. Unapproved entries on MyAnimeList are those that are user submitted and have not yet been approved by MAL to show up on other pages. They will have their own specifc pages and are often removed resulting in a 404 error. You do not need to pass a value to it. e.g usage: `?unapproved`
	Unapproved *Unapproved `form:"unapproved,omitempty" json:"unapproved,omitempty"`
	Page       *Page       `form:"page,omitempty" json:"page,omitempty"`
	Limit      *Limit      `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetSchedulesParamsFilter defines parameters for GetSchedules.
type GetSchedulesParamsFilter string

// GetSchedulesParamsKids defines parameters for GetSchedules.
type GetSchedulesParamsKids string

// GetSchedulesParamsSfw defines parameters for GetSchedules.
type GetSchedulesParamsSfw string

// GetSeasonNowParams defines parameters for GetSeasonNow.
type GetSeasonNowParams struct {
	// Filter Entry types
	Filter *GetSeasonNowParamsFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// Sfw 'Safe For Work'. This is a flag. When supplied it will filter out entries according to the SFW Policy. You do not need to pass a value to it. e.g usage: `?sfw`
	Sfw *Sfw `form:"sfw,omitempty" json:"sfw,omitempty"`

	// Unapproved This is a flag. When supplied it will include entries which are unapproved. Unapproved entries on MyAnimeList are those that are user submitted and have not yet been approved by MAL to show up on other pages. They will have their own specifc pages and are often removed resulting in a 404 error. You do not need to pass a value to it. e.g usage: `?unapproved`
	Unapproved *Unapproved `form:"unapproved,omitempty" json:"unapproved,omitempty"`

	// Continuing This is a flag. When supplied it will include entries which are continuing from previous seasons. MAL includes these items on the seasons view in the &#8243;TV (continuing)&#8243; section. (Example: https://myanimelist.net/anime/season/2024/winter) <br />Example usage: `?continuing`
	Continuing *Continuing `form:"continuing,omitempty" json:"continuing,omitempty"`
	Page       *Page       `form:"page,omitempty" json:"page,omitempty"`
	Limit      *Limit      `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetSeasonNowParamsFilter defines parameters for GetSeasonNow.
type GetSeasonNowParamsFilter string

// GetSeasonUpcomingParams defines parameters for GetSeasonUpcoming.
type GetSeasonUpcomingParams struct {
	// Filter Entry types
	Filter *GetSeasonUpcomingParamsFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// Sfw 'Safe For Work'. This is a flag. When supplied it will filter out entries according to the SFW Policy. You do not need to pass a value to it. e.g usage: `?sfw`
	Sfw *Sfw `form:"sfw,omitempty" json:"sfw,omitempty"`

	// Unapproved This is a flag. When supplied it will include entries which are unapproved. Unapproved entries on MyAnimeList are those that are user submitted and have not yet been approved by MAL to show up on other pages. They will have their own specifc pages and are often removed resulting in a 404 error. You do not need to pass a value to it. e.g usage: `?unapproved`
	Unapproved *Unapproved `form:"unapproved,omitempty" json:"unapproved,omitempty"`

	// Continuing This is a flag. When supplied it will include entries which are continuing from previous seasons. MAL includes these items on the seasons view in the &#8243;TV (continuing)&#8243; section. (Example: https://myanimelist.net/anime/season/2024/winter) <br />Example usage: `?continuing`
	Continuing *Continuing `form:"continuing,omitempty" json:"continuing,omitempty"`
	Page       *Page       `form:"page,omitempty" json:"page,omitempty"`
	Limit      *Limit      `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetSeasonUpcomingParamsFilter defines parameters for GetSeasonUpcoming.
type GetSeasonUpcomingParamsFilter string

// GetSeasonParams defines parameters for GetSeason.
type GetSeasonParams struct {
	// Filter Entry types
	Filter *GetSeasonParamsFilter `form:"filter,omitempty" json:"filter,omitempty"`

	// Sfw 'Safe For Work'. This is a flag. When supplied it will filter out entries according to the SFW Policy. You do not need to pass a value to it. e.g usage: `?sfw`
	Sfw *Sfw `form:"sfw,omitempty" json:"sfw,omitempty"`

	// Unapproved This is a flag. When supplied it will include entries which are unapproved. Unapproved entries on MyAnimeList are those that are user submitted and have not yet been approved by MAL to show up on other pages. They will have their own specifc pages and are often removed resulting in a 404 error. You do not need to pass a value to it. e.g usage: `?unapproved`
	Unapproved *Unapproved `form:"unapproved,omitempty" json:"unapproved,omitempty"`

	// Continuing This is a flag. When supplied it will include entries which are continuing from previous seasons. MAL includes these items on the seasons view in the &#8243;TV (continuing)&#8243; section. (Example: https://myanimelist.net/anime/season/2024/winter) <br />Example usage: `?continuing`
	Continuing *Continuing `form:"continuing,omitempty" json:"continuing,omitempty"`
	Page       *Page       `form:"page,omitempty" json:"page,omitempty"`
	Limit      *Limit      `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetSeasonParamsFilter defines parameters for GetSeason.
type GetSeasonParamsFilter string

// GetTopAnimeParams defines parameters for GetTopAnime.
type GetTopAnimeParams struct {
	Type   *AnimeSearchQueryType   `form:"type,omitempty" json:"type,omitempty"`
	Filter *TopAnimeFilter         `form:"filter,omitempty" json:"filter,omitempty"`
	Rating *AnimeSearchQueryRating `form:"rating,omitempty" json:"rating,omitempty"`

	// Sfw Filter out Adult entries
	Sfw   *bool  `form:"sfw,omitempty" json:"sfw,omitempty"`
	Page  *Page  `form:"page,omitempty" json:"page,omitempty"`
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetTopCharactersParams defines parameters for GetTopCharacters.
type GetTopCharactersParams struct {
	Page  *Page  `form:"page,omitempty" json:"page,omitempty"`
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetTopMangaParams defines parameters for GetTopManga.
type GetTopMangaParams struct {
	Type   *MangaSearchQueryType `form:"type,omitempty" json:"type,omitempty"`
	Filter *TopMangaFilter       `form:"filter,omitempty" json:"filter,omitempty"`
	Page   *Page                 `form:"page,omitempty" json:"page,omitempty"`
	Limit  *Limit                `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetTopPeopleParams defines parameters for GetTopPeople.
type GetTopPeopleParams struct {
	Page  *Page  `form:"page,omitempty" json:"page,omitempty"`
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetTopReviewsParams defines parameters for GetTopReviews.
type GetTopReviewsParams struct {
	Page *Page               `form:"page,omitempty" json:"page,omitempty"`
	Type *TopReviewsTypeEnum `form:"type,omitempty" json:"type,omitempty"`

	// Preliminary Whether the results include preliminary reviews or not. Defaults to true.
	Preliminary *bool `form:"preliminary,omitempty" json:"preliminary,omitempty"`

	// Spoilers Whether the results include reviews with spoilers or not. Defaults to true.
	Spoilers *bool `form:"spoilers,omitempty" json:"spoilers,omitempty"`
}

// GetUsersSearchParams defines parameters for GetUsersSearch.
type GetUsersSearchParams struct {
	Page     *Page                   `form:"page,omitempty" json:"page,omitempty"`
	Limit    *Limit                  `form:"limit,omitempty" json:"limit,omitempty"`
	Q        *string                 `form:"q,omitempty" json:"q,omitempty"`
	Gender   *UsersSearchQueryGender `form:"gender,omitempty" json:"gender,omitempty"`
	Location *string                 `form:"location,omitempty" json:"location,omitempty"`
	MaxAge   *int                    `form:"maxAge,omitempty" json:"maxAge,omitempty"`
	MinAge   *int                    `form:"minAge,omitempty" json:"minAge,omitempty"`
}

// GetUserAnimelistParams defines parameters for GetUserAnimelist.
type GetUserAnimelistParams struct {
	Status *UserAnimeListStatusFilter `form:"status,omitempty" json:"status,omitempty"`
}

// GetUserClubsParams defines parameters for GetUserClubs.
type GetUserClubsParams struct {
	Page *Page `form:"page,omitempty" json:"page,omitempty"`
}

// GetUserFriendsParams defines parameters for GetUserFriends.
type GetUserFriendsParams struct {
	Page *Page `form:"page,omitempty" json:"page,omitempty"`
}

// GetUserHistoryParams defines parameters for GetUserHistory.
type GetUserHistoryParams struct {
	Type *GetUserHistoryParamsType `form:"type,omitempty" json:"type,omitempty"`
}

// GetUserHistoryParamsType defines parameters for GetUserHistory.
type GetUserHistoryParamsType string

// GetUserMangaListParams defines parameters for GetUserMangaList.
type GetUserMangaListParams struct {
	Status *UserMangaListStatusFilter `form:"status,omitempty" json:"status,omitempty"`
}

// GetUserRecommendationsParams defines parameters for GetUserRecommendations.
type GetUserRecommendationsParams struct {
	Page *Page `form:"page,omitempty" json:"page,omitempty"`
}

// GetUserReviewsParams defines parameters for GetUserReviews.
type GetUserReviewsParams struct {
	Page *Page `form:"page,omitempty" json:"page,omitempty"`
}

// GetWatchRecentPromosParams defines parameters for GetWatchRecentPromos.
type GetWatchRecentPromosParams struct {
	Page *Page `form:"page,omitempty" json:"page,omitempty"`
}

// AsAnimeMeta returns the union data inside the EntryRecommendations_Data_Entry as a AnimeMeta
func (t EntryRecommendations_Data_Entry) AsAnimeMeta() (AnimeMeta, error) {
	var body AnimeMeta
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAnimeMeta overwrites any union data inside the EntryRecommendations_Data_Entry as the provided AnimeMeta
func (t *EntryRecommendations_Data_Entry) FromAnimeMeta(v AnimeMeta) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAnimeMeta performs a merge with any union data inside the EntryRecommendations_Data_Entry, using the provided AnimeMeta
func (t *EntryRecommendations_Data_Entry) MergeAnimeMeta(v AnimeMeta) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMangaMeta returns the union data inside the EntryRecommendations_Data_Entry as a MangaMeta
func (t EntryRecommendations_Data_Entry) AsMangaMeta() (MangaMeta, error) {
	var body MangaMeta
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMangaMeta overwrites any union data inside the EntryRecommendations_Data_Entry as the provided MangaMeta
func (t *EntryRecommendations_Data_Entry) FromMangaMeta(v MangaMeta) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMangaMeta performs a merge with any union data inside the EntryRecommendations_Data_Entry, using the provided MangaMeta
func (t *EntryRecommendations_Data_Entry) MergeMangaMeta(v MangaMeta) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t EntryRecommendations_Data_Entry) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *EntryRecommendations_Data_Entry) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAnime returns the union data inside the Random_Data_Item as a Anime
func (t Random_Data_Item) AsAnime() (Anime, error) {
	var body Anime
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAnime overwrites any union data inside the Random_Data_Item as the provided Anime
func (t *Random_Data_Item) FromAnime(v Anime) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAnime performs a merge with any union data inside the Random_Data_Item, using the provided Anime
func (t *Random_Data_Item) MergeAnime(v Anime) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsManga returns the union data inside the Random_Data_Item as a Manga
func (t Random_Data_Item) AsManga() (Manga, error) {
	var body Manga
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromManga overwrites any union data inside the Random_Data_Item as the provided Manga
func (t *Random_Data_Item) FromManga(v Manga) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeManga performs a merge with any union data inside the Random_Data_Item, using the provided Manga
func (t *Random_Data_Item) MergeManga(v Manga) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsCharacter returns the union data inside the Random_Data_Item as a Character
func (t Random_Data_Item) AsCharacter() (Character, error) {
	var body Character
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromCharacter overwrites any union data inside the Random_Data_Item as the provided Character
func (t *Random_Data_Item) FromCharacter(v Character) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeCharacter performs a merge with any union data inside the Random_Data_Item, using the provided Character
func (t *Random_Data_Item) MergeCharacter(v Character) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPerson returns the union data inside the Random_Data_Item as a Person
func (t Random_Data_Item) AsPerson() (Person, error) {
	var body Person
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPerson overwrites any union data inside the Random_Data_Item as the provided Person
func (t *Random_Data_Item) FromPerson(v Person) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePerson performs a merge with any union data inside the Random_Data_Item, using the provided Person
func (t *Random_Data_Item) MergePerson(v Person) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Random_Data_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Random_Data_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAnimeMeta returns the union data inside the Recommendations_Data_Entry_Item as a AnimeMeta
func (t Recommendations_Data_Entry_Item) AsAnimeMeta() (AnimeMeta, error) {
	var body AnimeMeta
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAnimeMeta overwrites any union data inside the Recommendations_Data_Entry_Item as the provided AnimeMeta
func (t *Recommendations_Data_Entry_Item) FromAnimeMeta(v AnimeMeta) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAnimeMeta performs a merge with any union data inside the Recommendations_Data_Entry_Item, using the provided AnimeMeta
func (t *Recommendations_Data_Entry_Item) MergeAnimeMeta(v AnimeMeta) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMangaMeta returns the union data inside the Recommendations_Data_Entry_Item as a MangaMeta
func (t Recommendations_Data_Entry_Item) AsMangaMeta() (MangaMeta, error) {
	var body MangaMeta
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMangaMeta overwrites any union data inside the Recommendations_Data_Entry_Item as the provided MangaMeta
func (t *Recommendations_Data_Entry_Item) FromMangaMeta(v MangaMeta) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMangaMeta performs a merge with any union data inside the Recommendations_Data_Entry_Item, using the provided MangaMeta
func (t *Recommendations_Data_Entry_Item) MergeMangaMeta(v MangaMeta) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Recommendations_Data_Entry_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Recommendations_Data_Entry_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsAnimeReview returns the union data inside the ReviewsCollection_Data_Item as a AnimeReview
func (t ReviewsCollection_Data_Item) AsAnimeReview() (AnimeReview, error) {
	var body AnimeReview
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAnimeReview overwrites any union data inside the ReviewsCollection_Data_Item as the provided AnimeReview
func (t *ReviewsCollection_Data_Item) FromAnimeReview(v AnimeReview) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAnimeReview performs a merge with any union data inside the ReviewsCollection_Data_Item, using the provided AnimeReview
func (t *ReviewsCollection_Data_Item) MergeAnimeReview(v AnimeReview) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsMangaReview returns the union data inside the ReviewsCollection_Data_Item as a MangaReview
func (t ReviewsCollection_Data_Item) AsMangaReview() (MangaReview, error) {
	var body MangaReview
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromMangaReview overwrites any union data inside the ReviewsCollection_Data_Item as the provided MangaReview
func (t *ReviewsCollection_Data_Item) FromMangaReview(v MangaReview) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeMangaReview performs a merge with any union data inside the ReviewsCollection_Data_Item, using the provided MangaReview
func (t *ReviewsCollection_Data_Item) MergeMangaReview(v MangaReview) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t ReviewsCollection_Data_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *ReviewsCollection_Data_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAnimeSearch request
	GetAnimeSearch(ctx context.Context, params *GetAnimeSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnimeById request
	GetAnimeById(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnimeCharacters request
	GetAnimeCharacters(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnimeEpisodes request
	GetAnimeEpisodes(ctx context.Context, id int, params *GetAnimeEpisodesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnimeEpisodeById request
	GetAnimeEpisodeById(ctx context.Context, id int, episode int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnimeExternal request
	GetAnimeExternal(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnimeForum request
	GetAnimeForum(ctx context.Context, id int, params *GetAnimeForumParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnimeFullById request
	GetAnimeFullById(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnimeMoreInfo request
	GetAnimeMoreInfo(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnimeNews request
	GetAnimeNews(ctx context.Context, id int, params *GetAnimeNewsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnimePictures request
	GetAnimePictures(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnimeRecommendations request
	GetAnimeRecommendations(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnimeRelations request
	GetAnimeRelations(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnimeReviews request
	GetAnimeReviews(ctx context.Context, id int, params *GetAnimeReviewsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnimeStaff request
	GetAnimeStaff(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnimeStatistics request
	GetAnimeStatistics(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnimeStreaming request
	GetAnimeStreaming(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnimeThemes request
	GetAnimeThemes(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnimeUserUpdates request
	GetAnimeUserUpdates(ctx context.Context, id int, params *GetAnimeUserUpdatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnimeVideos request
	GetAnimeVideos(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnimeVideosEpisodes request
	GetAnimeVideosEpisodes(ctx context.Context, id int, params *GetAnimeVideosEpisodesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCharactersSearch request
	GetCharactersSearch(ctx context.Context, params *GetCharactersSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCharacterById request
	GetCharacterById(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCharacterAnime request
	GetCharacterAnime(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCharacterFullById request
	GetCharacterFullById(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCharacterManga request
	GetCharacterManga(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCharacterPictures request
	GetCharacterPictures(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCharacterVoiceActors request
	GetCharacterVoiceActors(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClubsSearch request
	GetClubsSearch(ctx context.Context, params *GetClubsSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClubsById request
	GetClubsById(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClubMembers request
	GetClubMembers(ctx context.Context, id int, params *GetClubMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClubRelations request
	GetClubRelations(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClubStaff request
	GetClubStaff(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAnimeGenres request
	GetAnimeGenres(ctx context.Context, params *GetAnimeGenresParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMangaGenres request
	GetMangaGenres(ctx context.Context, params *GetMangaGenresParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMagazines request
	GetMagazines(ctx context.Context, params *GetMagazinesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMangaSearch request
	GetMangaSearch(ctx context.Context, params *GetMangaSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMangaById request
	GetMangaById(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMangaCharacters request
	GetMangaCharacters(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMangaExternal request
	GetMangaExternal(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMangaTopics request
	GetMangaTopics(ctx context.Context, id int, params *GetMangaTopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMangaFullById request
	GetMangaFullById(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMangaMoreInfo request
	GetMangaMoreInfo(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMangaNews request
	GetMangaNews(ctx context.Context, id int, params *GetMangaNewsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMangaPictures request
	GetMangaPictures(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMangaRecommendations request
	GetMangaRecommendations(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMangaRelations request
	GetMangaRelations(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMangaReviews request
	GetMangaReviews(ctx context.Context, id int, params *GetMangaReviewsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMangaStatistics request
	GetMangaStatistics(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMangaUserUpdates request
	GetMangaUserUpdates(ctx context.Context, id int, params *GetMangaUserUpdatesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPeopleSearch request
	GetPeopleSearch(ctx context.Context, params *GetPeopleSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersonById request
	GetPersonById(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersonAnime request
	GetPersonAnime(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersonFullById request
	GetPersonFullById(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersonManga request
	GetPersonManga(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersonPictures request
	GetPersonPictures(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPersonVoices request
	GetPersonVoices(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProducers request
	GetProducers(ctx context.Context, params *GetProducersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProducerById request
	GetProducerById(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProducerExternal request
	GetProducerExternal(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProducerFullById request
	GetProducerFullById(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRandomAnime request
	GetRandomAnime(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRandomCharacters request
	GetRandomCharacters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRandomManga request
	GetRandomManga(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRandomPeople request
	GetRandomPeople(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRandomUsers request
	GetRandomUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecentAnimeRecommendations request
	GetRecentAnimeRecommendations(ctx context.Context, params *GetRecentAnimeRecommendationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecentMangaRecommendations request
	GetRecentMangaRecommendations(ctx context.Context, params *GetRecentMangaRecommendationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecentAnimeReviews request
	GetRecentAnimeReviews(ctx context.Context, params *GetRecentAnimeReviewsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRecentMangaReviews request
	GetRecentMangaReviews(ctx context.Context, params *GetRecentMangaReviewsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSchedules request
	GetSchedules(ctx context.Context, params *GetSchedulesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSeasonsList request
	GetSeasonsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSeasonNow request
	GetSeasonNow(ctx context.Context, params *GetSeasonNowParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSeasonUpcoming request
	GetSeasonUpcoming(ctx context.Context, params *GetSeasonUpcomingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSeason request
	GetSeason(ctx context.Context, year int, season string, params *GetSeasonParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTopAnime request
	GetTopAnime(ctx context.Context, params *GetTopAnimeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTopCharacters request
	GetTopCharacters(ctx context.Context, params *GetTopCharactersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTopManga request
	GetTopManga(ctx context.Context, params *GetTopMangaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTopPeople request
	GetTopPeople(ctx context.Context, params *GetTopPeopleParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTopReviews request
	GetTopReviews(ctx context.Context, params *GetTopReviewsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersSearch request
	GetUsersSearch(ctx context.Context, params *GetUsersSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserById request
	GetUserById(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserProfile request
	GetUserProfile(ctx context.Context, username string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserAbout request
	GetUserAbout(ctx context.Context, username string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserAnimelist request
	GetUserAnimelist(ctx context.Context, username string, params *GetUserAnimelistParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserClubs request
	GetUserClubs(ctx context.Context, username string, params *GetUserClubsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserExternal request
	GetUserExternal(ctx context.Context, username string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserFavorites request
	GetUserFavorites(ctx context.Context, username string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserFriends request
	GetUserFriends(ctx context.Context, username string, params *GetUserFriendsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserFullProfile request
	GetUserFullProfile(ctx context.Context, username string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserHistory request
	GetUserHistory(ctx context.Context, username string, params *GetUserHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserMangaList request
	GetUserMangaList(ctx context.Context, username string, params *GetUserMangaListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserRecommendations request
	GetUserRecommendations(ctx context.Context, username string, params *GetUserRecommendationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserReviews request
	GetUserReviews(ctx context.Context, username string, params *GetUserReviewsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserStatistics request
	GetUserStatistics(ctx context.Context, username string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserUpdates request
	GetUserUpdates(ctx context.Context, username string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWatchRecentEpisodes request
	GetWatchRecentEpisodes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWatchPopularEpisodes request
	GetWatchPopularEpisodes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWatchRecentPromos request
	GetWatchRecentPromos(ctx context.Context, params *GetWatchRecentPromosParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWatchPopularPromos request
	GetWatchPopularPromos(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAnimeSearch(ctx context.Context, params *GetAnimeSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnimeSearchRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnimeById(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnimeByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnimeCharacters(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnimeCharactersRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnimeEpisodes(ctx context.Context, id int, params *GetAnimeEpisodesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnimeEpisodesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnimeEpisodeById(ctx context.Context, id int, episode int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnimeEpisodeByIdRequest(c.Server, id, episode)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnimeExternal(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnimeExternalRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnimeForum(ctx context.Context, id int, params *GetAnimeForumParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnimeForumRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnimeFullById(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnimeFullByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnimeMoreInfo(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnimeMoreInfoRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnimeNews(ctx context.Context, id int, params *GetAnimeNewsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnimeNewsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnimePictures(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnimePicturesRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnimeRecommendations(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnimeRecommendationsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnimeRelations(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnimeRelationsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnimeReviews(ctx context.Context, id int, params *GetAnimeReviewsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnimeReviewsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnimeStaff(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnimeStaffRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnimeStatistics(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnimeStatisticsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnimeStreaming(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnimeStreamingRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnimeThemes(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnimeThemesRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnimeUserUpdates(ctx context.Context, id int, params *GetAnimeUserUpdatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnimeUserUpdatesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnimeVideos(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnimeVideosRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnimeVideosEpisodes(ctx context.Context, id int, params *GetAnimeVideosEpisodesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnimeVideosEpisodesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCharactersSearch(ctx context.Context, params *GetCharactersSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCharactersSearchRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCharacterById(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCharacterByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCharacterAnime(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCharacterAnimeRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCharacterFullById(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCharacterFullByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCharacterManga(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCharacterMangaRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCharacterPictures(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCharacterPicturesRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCharacterVoiceActors(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCharacterVoiceActorsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClubsSearch(ctx context.Context, params *GetClubsSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClubsSearchRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClubsById(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClubsByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClubMembers(ctx context.Context, id int, params *GetClubMembersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClubMembersRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClubRelations(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClubRelationsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClubStaff(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClubStaffRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAnimeGenres(ctx context.Context, params *GetAnimeGenresParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAnimeGenresRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMangaGenres(ctx context.Context, params *GetMangaGenresParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMangaGenresRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMagazines(ctx context.Context, params *GetMagazinesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMagazinesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMangaSearch(ctx context.Context, params *GetMangaSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMangaSearchRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMangaById(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMangaByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMangaCharacters(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMangaCharactersRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMangaExternal(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMangaExternalRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMangaTopics(ctx context.Context, id int, params *GetMangaTopicsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMangaTopicsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMangaFullById(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMangaFullByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMangaMoreInfo(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMangaMoreInfoRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMangaNews(ctx context.Context, id int, params *GetMangaNewsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMangaNewsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMangaPictures(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMangaPicturesRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMangaRecommendations(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMangaRecommendationsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMangaRelations(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMangaRelationsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMangaReviews(ctx context.Context, id int, params *GetMangaReviewsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMangaReviewsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMangaStatistics(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMangaStatisticsRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMangaUserUpdates(ctx context.Context, id int, params *GetMangaUserUpdatesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMangaUserUpdatesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPeopleSearch(ctx context.Context, params *GetPeopleSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPeopleSearchRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersonById(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersonByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersonAnime(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersonAnimeRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersonFullById(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersonFullByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersonManga(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersonMangaRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersonPictures(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersonPicturesRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPersonVoices(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPersonVoicesRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProducers(ctx context.Context, params *GetProducersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProducersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProducerById(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProducerByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProducerExternal(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProducerExternalRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProducerFullById(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProducerFullByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRandomAnime(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRandomAnimeRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRandomCharacters(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRandomCharactersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRandomManga(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRandomMangaRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRandomPeople(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRandomPeopleRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRandomUsers(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRandomUsersRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecentAnimeRecommendations(ctx context.Context, params *GetRecentAnimeRecommendationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecentAnimeRecommendationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecentMangaRecommendations(ctx context.Context, params *GetRecentMangaRecommendationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecentMangaRecommendationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecentAnimeReviews(ctx context.Context, params *GetRecentAnimeReviewsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecentAnimeReviewsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRecentMangaReviews(ctx context.Context, params *GetRecentMangaReviewsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRecentMangaReviewsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSchedules(ctx context.Context, params *GetSchedulesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSchedulesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSeasonsList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSeasonsListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSeasonNow(ctx context.Context, params *GetSeasonNowParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSeasonNowRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSeasonUpcoming(ctx context.Context, params *GetSeasonUpcomingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSeasonUpcomingRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSeason(ctx context.Context, year int, season string, params *GetSeasonParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSeasonRequest(c.Server, year, season, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTopAnime(ctx context.Context, params *GetTopAnimeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTopAnimeRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTopCharacters(ctx context.Context, params *GetTopCharactersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTopCharactersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTopManga(ctx context.Context, params *GetTopMangaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTopMangaRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTopPeople(ctx context.Context, params *GetTopPeopleParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTopPeopleRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTopReviews(ctx context.Context, params *GetTopReviewsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTopReviewsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersSearch(ctx context.Context, params *GetUsersSearchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersSearchRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserById(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserByIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserProfile(ctx context.Context, username string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserProfileRequest(c.Server, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserAbout(ctx context.Context, username string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserAboutRequest(c.Server, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserAnimelist(ctx context.Context, username string, params *GetUserAnimelistParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserAnimelistRequest(c.Server, username, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserClubs(ctx context.Context, username string, params *GetUserClubsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserClubsRequest(c.Server, username, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserExternal(ctx context.Context, username string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserExternalRequest(c.Server, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserFavorites(ctx context.Context, username string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserFavoritesRequest(c.Server, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserFriends(ctx context.Context, username string, params *GetUserFriendsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserFriendsRequest(c.Server, username, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserFullProfile(ctx context.Context, username string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserFullProfileRequest(c.Server, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserHistory(ctx context.Context, username string, params *GetUserHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserHistoryRequest(c.Server, username, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserMangaList(ctx context.Context, username string, params *GetUserMangaListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserMangaListRequest(c.Server, username, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserRecommendations(ctx context.Context, username string, params *GetUserRecommendationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRecommendationsRequest(c.Server, username, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserReviews(ctx context.Context, username string, params *GetUserReviewsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserReviewsRequest(c.Server, username, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserStatistics(ctx context.Context, username string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserStatisticsRequest(c.Server, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserUpdates(ctx context.Context, username string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserUpdatesRequest(c.Server, username)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWatchRecentEpisodes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWatchRecentEpisodesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWatchPopularEpisodes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWatchPopularEpisodesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWatchRecentPromos(ctx context.Context, params *GetWatchRecentPromosParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWatchRecentPromosRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWatchPopularPromos(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWatchPopularPromosRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAnimeSearchRequest generates requests for GetAnimeSearch
func NewGetAnimeSearchRequest(server string, params *GetAnimeSearchParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anime")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Unapproved != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unapproved", runtime.ParamLocationQuery, *params.Unapproved); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Score != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "score", runtime.ParamLocationQuery, *params.Score); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinScore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_score", runtime.ParamLocationQuery, *params.MinScore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxScore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_score", runtime.ParamLocationQuery, *params.MaxScore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Rating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rating", runtime.ParamLocationQuery, *params.Rating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sfw != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sfw", runtime.ParamLocationQuery, *params.Sfw); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Genres != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "genres", runtime.ParamLocationQuery, *params.Genres); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GenresExclude != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "genres_exclude", runtime.ParamLocationQuery, *params.GenresExclude); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Letter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "letter", runtime.ParamLocationQuery, *params.Letter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Producers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "producers", runtime.ParamLocationQuery, *params.Producers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_date", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_date", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnimeByIdRequest generates requests for GetAnimeById
func NewGetAnimeByIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anime/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnimeCharactersRequest generates requests for GetAnimeCharacters
func NewGetAnimeCharactersRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anime/%s/characters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnimeEpisodesRequest generates requests for GetAnimeEpisodes
func NewGetAnimeEpisodesRequest(server string, id int, params *GetAnimeEpisodesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anime/%s/episodes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnimeEpisodeByIdRequest generates requests for GetAnimeEpisodeById
func NewGetAnimeEpisodeByIdRequest(server string, id int, episode int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "episode", runtime.ParamLocationPath, episode)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anime/%s/episodes/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnimeExternalRequest generates requests for GetAnimeExternal
func NewGetAnimeExternalRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anime/%s/external", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnimeForumRequest generates requests for GetAnimeForum
func NewGetAnimeForumRequest(server string, id int, params *GetAnimeForumParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anime/%s/forum", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnimeFullByIdRequest generates requests for GetAnimeFullById
func NewGetAnimeFullByIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anime/%s/full", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnimeMoreInfoRequest generates requests for GetAnimeMoreInfo
func NewGetAnimeMoreInfoRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anime/%s/moreinfo", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnimeNewsRequest generates requests for GetAnimeNews
func NewGetAnimeNewsRequest(server string, id int, params *GetAnimeNewsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anime/%s/news", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnimePicturesRequest generates requests for GetAnimePictures
func NewGetAnimePicturesRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anime/%s/pictures", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnimeRecommendationsRequest generates requests for GetAnimeRecommendations
func NewGetAnimeRecommendationsRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anime/%s/recommendations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnimeRelationsRequest generates requests for GetAnimeRelations
func NewGetAnimeRelationsRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anime/%s/relations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnimeReviewsRequest generates requests for GetAnimeReviews
func NewGetAnimeReviewsRequest(server string, id int, params *GetAnimeReviewsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anime/%s/reviews", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Preliminary != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preliminary", runtime.ParamLocationQuery, *params.Preliminary); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Spoilers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "spoilers", runtime.ParamLocationQuery, *params.Spoilers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnimeStaffRequest generates requests for GetAnimeStaff
func NewGetAnimeStaffRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anime/%s/staff", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnimeStatisticsRequest generates requests for GetAnimeStatistics
func NewGetAnimeStatisticsRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anime/%s/statistics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnimeStreamingRequest generates requests for GetAnimeStreaming
func NewGetAnimeStreamingRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anime/%s/streaming", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnimeThemesRequest generates requests for GetAnimeThemes
func NewGetAnimeThemesRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anime/%s/themes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnimeUserUpdatesRequest generates requests for GetAnimeUserUpdates
func NewGetAnimeUserUpdatesRequest(server string, id int, params *GetAnimeUserUpdatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anime/%s/userupdates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnimeVideosRequest generates requests for GetAnimeVideos
func NewGetAnimeVideosRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anime/%s/videos", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnimeVideosEpisodesRequest generates requests for GetAnimeVideosEpisodes
func NewGetAnimeVideosEpisodesRequest(server string, id int, params *GetAnimeVideosEpisodesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/anime/%s/videos/episodes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCharactersSearchRequest generates requests for GetCharactersSearch
func NewGetCharactersSearchRequest(server string, params *GetCharactersSearchParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/characters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Letter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "letter", runtime.ParamLocationQuery, *params.Letter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCharacterByIdRequest generates requests for GetCharacterById
func NewGetCharacterByIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/characters/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCharacterAnimeRequest generates requests for GetCharacterAnime
func NewGetCharacterAnimeRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/characters/%s/anime", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCharacterFullByIdRequest generates requests for GetCharacterFullById
func NewGetCharacterFullByIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/characters/%s/full", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCharacterMangaRequest generates requests for GetCharacterManga
func NewGetCharacterMangaRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/characters/%s/manga", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCharacterPicturesRequest generates requests for GetCharacterPictures
func NewGetCharacterPicturesRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/characters/%s/pictures", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCharacterVoiceActorsRequest generates requests for GetCharacterVoiceActors
func NewGetCharacterVoiceActorsRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/characters/%s/voices", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClubsSearchRequest generates requests for GetClubsSearch
func NewGetClubsSearchRequest(server string, params *GetClubsSearchParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clubs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Category != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "category", runtime.ParamLocationQuery, *params.Category); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Letter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "letter", runtime.ParamLocationQuery, *params.Letter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClubsByIdRequest generates requests for GetClubsById
func NewGetClubsByIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clubs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClubMembersRequest generates requests for GetClubMembers
func NewGetClubMembersRequest(server string, id int, params *GetClubMembersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clubs/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClubRelationsRequest generates requests for GetClubRelations
func NewGetClubRelationsRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clubs/%s/relations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClubStaffRequest generates requests for GetClubStaff
func NewGetClubStaffRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/clubs/%s/staff", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAnimeGenresRequest generates requests for GetAnimeGenres
func NewGetAnimeGenresRequest(server string, params *GetAnimeGenresParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/genres/anime")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMangaGenresRequest generates requests for GetMangaGenres
func NewGetMangaGenresRequest(server string, params *GetMangaGenresParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/genres/manga")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMagazinesRequest generates requests for GetMagazines
func NewGetMagazinesRequest(server string, params *GetMagazinesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/magazines")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Letter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "letter", runtime.ParamLocationQuery, *params.Letter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMangaSearchRequest generates requests for GetMangaSearch
func NewGetMangaSearchRequest(server string, params *GetMangaSearchParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Unapproved != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unapproved", runtime.ParamLocationQuery, *params.Unapproved); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Score != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "score", runtime.ParamLocationQuery, *params.Score); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinScore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "min_score", runtime.ParamLocationQuery, *params.MinScore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxScore != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "max_score", runtime.ParamLocationQuery, *params.MaxScore); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sfw != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sfw", runtime.ParamLocationQuery, *params.Sfw); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Genres != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "genres", runtime.ParamLocationQuery, *params.Genres); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.GenresExclude != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "genres_exclude", runtime.ParamLocationQuery, *params.GenresExclude); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Letter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "letter", runtime.ParamLocationQuery, *params.Letter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Magazines != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "magazines", runtime.ParamLocationQuery, *params.Magazines); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start_date", runtime.ParamLocationQuery, *params.StartDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EndDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end_date", runtime.ParamLocationQuery, *params.EndDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMangaByIdRequest generates requests for GetMangaById
func NewGetMangaByIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMangaCharactersRequest generates requests for GetMangaCharacters
func NewGetMangaCharactersRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga/%s/characters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMangaExternalRequest generates requests for GetMangaExternal
func NewGetMangaExternalRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga/%s/external", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMangaTopicsRequest generates requests for GetMangaTopics
func NewGetMangaTopicsRequest(server string, id int, params *GetMangaTopicsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga/%s/forum", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMangaFullByIdRequest generates requests for GetMangaFullById
func NewGetMangaFullByIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga/%s/full", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMangaMoreInfoRequest generates requests for GetMangaMoreInfo
func NewGetMangaMoreInfoRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga/%s/moreinfo", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMangaNewsRequest generates requests for GetMangaNews
func NewGetMangaNewsRequest(server string, id int, params *GetMangaNewsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga/%s/news", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMangaPicturesRequest generates requests for GetMangaPictures
func NewGetMangaPicturesRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga/%s/pictures", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMangaRecommendationsRequest generates requests for GetMangaRecommendations
func NewGetMangaRecommendationsRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga/%s/recommendations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMangaRelationsRequest generates requests for GetMangaRelations
func NewGetMangaRelationsRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga/%s/relations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMangaReviewsRequest generates requests for GetMangaReviews
func NewGetMangaReviewsRequest(server string, id int, params *GetMangaReviewsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga/%s/reviews", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Preliminary != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preliminary", runtime.ParamLocationQuery, *params.Preliminary); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Spoilers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "spoilers", runtime.ParamLocationQuery, *params.Spoilers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMangaStatisticsRequest generates requests for GetMangaStatistics
func NewGetMangaStatisticsRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga/%s/statistics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMangaUserUpdatesRequest generates requests for GetMangaUserUpdates
func NewGetMangaUserUpdatesRequest(server string, id int, params *GetMangaUserUpdatesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga/%s/userupdates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPeopleSearchRequest generates requests for GetPeopleSearch
func NewGetPeopleSearchRequest(server string, params *GetPeopleSearchParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/people")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Letter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "letter", runtime.ParamLocationQuery, *params.Letter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersonByIdRequest generates requests for GetPersonById
func NewGetPersonByIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/people/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersonAnimeRequest generates requests for GetPersonAnime
func NewGetPersonAnimeRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/people/%s/anime", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersonFullByIdRequest generates requests for GetPersonFullById
func NewGetPersonFullByIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/people/%s/full", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersonMangaRequest generates requests for GetPersonManga
func NewGetPersonMangaRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/people/%s/manga", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersonPicturesRequest generates requests for GetPersonPictures
func NewGetPersonPicturesRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/people/%s/pictures", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPersonVoicesRequest generates requests for GetPersonVoices
func NewGetPersonVoicesRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/people/%s/voices", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProducersRequest generates requests for GetProducers
func NewGetProducersRequest(server string, params *GetProducersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/producers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OrderBy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "order_by", runtime.ParamLocationQuery, *params.OrderBy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Letter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "letter", runtime.ParamLocationQuery, *params.Letter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProducerByIdRequest generates requests for GetProducerById
func NewGetProducerByIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/producers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProducerExternalRequest generates requests for GetProducerExternal
func NewGetProducerExternalRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/producers/%s/external", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProducerFullByIdRequest generates requests for GetProducerFullById
func NewGetProducerFullByIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/producers/%s/full", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRandomAnimeRequest generates requests for GetRandomAnime
func NewGetRandomAnimeRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/random/anime")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRandomCharactersRequest generates requests for GetRandomCharacters
func NewGetRandomCharactersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/random/characters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRandomMangaRequest generates requests for GetRandomManga
func NewGetRandomMangaRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/random/manga")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRandomPeopleRequest generates requests for GetRandomPeople
func NewGetRandomPeopleRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/random/people")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRandomUsersRequest generates requests for GetRandomUsers
func NewGetRandomUsersRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/random/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRecentAnimeRecommendationsRequest generates requests for GetRecentAnimeRecommendations
func NewGetRecentAnimeRecommendationsRequest(server string, params *GetRecentAnimeRecommendationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recommendations/anime")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRecentMangaRecommendationsRequest generates requests for GetRecentMangaRecommendations
func NewGetRecentMangaRecommendationsRequest(server string, params *GetRecentMangaRecommendationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/recommendations/manga")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRecentAnimeReviewsRequest generates requests for GetRecentAnimeReviews
func NewGetRecentAnimeReviewsRequest(server string, params *GetRecentAnimeReviewsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reviews/anime")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Preliminary != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preliminary", runtime.ParamLocationQuery, *params.Preliminary); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Spoilers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "spoilers", runtime.ParamLocationQuery, *params.Spoilers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRecentMangaReviewsRequest generates requests for GetRecentMangaReviews
func NewGetRecentMangaReviewsRequest(server string, params *GetRecentMangaReviewsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reviews/manga")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Preliminary != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preliminary", runtime.ParamLocationQuery, *params.Preliminary); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Spoilers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "spoilers", runtime.ParamLocationQuery, *params.Spoilers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSchedulesRequest generates requests for GetSchedules
func NewGetSchedulesRequest(server string, params *GetSchedulesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schedules")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Kids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kids", runtime.ParamLocationQuery, *params.Kids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sfw != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sfw", runtime.ParamLocationQuery, *params.Sfw); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Unapproved != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unapproved", runtime.ParamLocationQuery, *params.Unapproved); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSeasonsListRequest generates requests for GetSeasonsList
func NewGetSeasonsListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/seasons")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSeasonNowRequest generates requests for GetSeasonNow
func NewGetSeasonNowRequest(server string, params *GetSeasonNowParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/seasons/now")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sfw != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sfw", runtime.ParamLocationQuery, *params.Sfw); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Unapproved != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unapproved", runtime.ParamLocationQuery, *params.Unapproved); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Continuing != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuing", runtime.ParamLocationQuery, *params.Continuing); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSeasonUpcomingRequest generates requests for GetSeasonUpcoming
func NewGetSeasonUpcomingRequest(server string, params *GetSeasonUpcomingParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/seasons/upcoming")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sfw != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sfw", runtime.ParamLocationQuery, *params.Sfw); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Unapproved != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unapproved", runtime.ParamLocationQuery, *params.Unapproved); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Continuing != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuing", runtime.ParamLocationQuery, *params.Continuing); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSeasonRequest generates requests for GetSeason
func NewGetSeasonRequest(server string, year int, season string, params *GetSeasonParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "year", runtime.ParamLocationPath, year)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "season", runtime.ParamLocationPath, season)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/seasons/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sfw != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sfw", runtime.ParamLocationQuery, *params.Sfw); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Unapproved != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "unapproved", runtime.ParamLocationQuery, *params.Unapproved); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Continuing != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "continuing", runtime.ParamLocationQuery, *params.Continuing); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTopAnimeRequest generates requests for GetTopAnime
func NewGetTopAnimeRequest(server string, params *GetTopAnimeParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/top/anime")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Rating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rating", runtime.ParamLocationQuery, *params.Rating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sfw != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sfw", runtime.ParamLocationQuery, *params.Sfw); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTopCharactersRequest generates requests for GetTopCharacters
func NewGetTopCharactersRequest(server string, params *GetTopCharactersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/top/characters")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTopMangaRequest generates requests for GetTopManga
func NewGetTopMangaRequest(server string, params *GetTopMangaParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/top/manga")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Filter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter", runtime.ParamLocationQuery, *params.Filter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTopPeopleRequest generates requests for GetTopPeople
func NewGetTopPeopleRequest(server string, params *GetTopPeopleParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/top/people")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTopReviewsRequest generates requests for GetTopReviews
func NewGetTopReviewsRequest(server string, params *GetTopReviewsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/top/reviews")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Preliminary != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "preliminary", runtime.ParamLocationQuery, *params.Preliminary); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Spoilers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "spoilers", runtime.ParamLocationQuery, *params.Spoilers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersSearchRequest generates requests for GetUsersSearch
func NewGetUsersSearchRequest(server string, params *GetUsersSearchParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Gender != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "gender", runtime.ParamLocationQuery, *params.Gender); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Location != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "location", runtime.ParamLocationQuery, *params.Location); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MaxAge != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "maxAge", runtime.ParamLocationQuery, *params.MaxAge); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.MinAge != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "minAge", runtime.ParamLocationQuery, *params.MinAge); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserByIdRequest generates requests for GetUserById
func NewGetUserByIdRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/userbyid/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserProfileRequest generates requests for GetUserProfile
func NewGetUserProfileRequest(server string, username string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserAboutRequest generates requests for GetUserAbout
func NewGetUserAboutRequest(server string, username string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/about", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserAnimelistRequest generates requests for GetUserAnimelist
func NewGetUserAnimelistRequest(server string, username string, params *GetUserAnimelistParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/animelist", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserClubsRequest generates requests for GetUserClubs
func NewGetUserClubsRequest(server string, username string, params *GetUserClubsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/clubs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserExternalRequest generates requests for GetUserExternal
func NewGetUserExternalRequest(server string, username string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/external", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserFavoritesRequest generates requests for GetUserFavorites
func NewGetUserFavoritesRequest(server string, username string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/favorites", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserFriendsRequest generates requests for GetUserFriends
func NewGetUserFriendsRequest(server string, username string, params *GetUserFriendsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/friends", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserFullProfileRequest generates requests for GetUserFullProfile
func NewGetUserFullProfileRequest(server string, username string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/full", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserHistoryRequest generates requests for GetUserHistory
func NewGetUserHistoryRequest(server string, username string, params *GetUserHistoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/history", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserMangaListRequest generates requests for GetUserMangaList
func NewGetUserMangaListRequest(server string, username string, params *GetUserMangaListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/mangalist", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserRecommendationsRequest generates requests for GetUserRecommendations
func NewGetUserRecommendationsRequest(server string, username string, params *GetUserRecommendationsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/recommendations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserReviewsRequest generates requests for GetUserReviews
func NewGetUserReviewsRequest(server string, username string, params *GetUserReviewsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/reviews", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserStatisticsRequest generates requests for GetUserStatistics
func NewGetUserStatisticsRequest(server string, username string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/statistics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserUpdatesRequest generates requests for GetUserUpdates
func NewGetUserUpdatesRequest(server string, username string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "username", runtime.ParamLocationPath, username)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/userupdates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWatchRecentEpisodesRequest generates requests for GetWatchRecentEpisodes
func NewGetWatchRecentEpisodesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/watch/episodes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWatchPopularEpisodesRequest generates requests for GetWatchPopularEpisodes
func NewGetWatchPopularEpisodesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/watch/episodes/popular")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWatchRecentPromosRequest generates requests for GetWatchRecentPromos
func NewGetWatchRecentPromosRequest(server string, params *GetWatchRecentPromosParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/watch/promos")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWatchPopularPromosRequest generates requests for GetWatchPopularPromos
func NewGetWatchPopularPromosRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/watch/promos/popular")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAnimeSearchWithResponse request
	GetAnimeSearchWithResponse(ctx context.Context, params *GetAnimeSearchParams, reqEditors ...RequestEditorFn) (*GetAnimeSearchResponse, error)

	// GetAnimeByIdWithResponse request
	GetAnimeByIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetAnimeByIdResponse, error)

	// GetAnimeCharactersWithResponse request
	GetAnimeCharactersWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetAnimeCharactersResponse, error)

	// GetAnimeEpisodesWithResponse request
	GetAnimeEpisodesWithResponse(ctx context.Context, id int, params *GetAnimeEpisodesParams, reqEditors ...RequestEditorFn) (*GetAnimeEpisodesResponse, error)

	// GetAnimeEpisodeByIdWithResponse request
	GetAnimeEpisodeByIdWithResponse(ctx context.Context, id int, episode int, reqEditors ...RequestEditorFn) (*GetAnimeEpisodeByIdResponse, error)

	// GetAnimeExternalWithResponse request
	GetAnimeExternalWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetAnimeExternalResponse, error)

	// GetAnimeForumWithResponse request
	GetAnimeForumWithResponse(ctx context.Context, id int, params *GetAnimeForumParams, reqEditors ...RequestEditorFn) (*GetAnimeForumResponse, error)

	// GetAnimeFullByIdWithResponse request
	GetAnimeFullByIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetAnimeFullByIdResponse, error)

	// GetAnimeMoreInfoWithResponse request
	GetAnimeMoreInfoWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetAnimeMoreInfoResponse, error)

	// GetAnimeNewsWithResponse request
	GetAnimeNewsWithResponse(ctx context.Context, id int, params *GetAnimeNewsParams, reqEditors ...RequestEditorFn) (*GetAnimeNewsResponse, error)

	// GetAnimePicturesWithResponse request
	GetAnimePicturesWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetAnimePicturesResponse, error)

	// GetAnimeRecommendationsWithResponse request
	GetAnimeRecommendationsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetAnimeRecommendationsResponse, error)

	// GetAnimeRelationsWithResponse request
	GetAnimeRelationsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetAnimeRelationsResponse, error)

	// GetAnimeReviewsWithResponse request
	GetAnimeReviewsWithResponse(ctx context.Context, id int, params *GetAnimeReviewsParams, reqEditors ...RequestEditorFn) (*GetAnimeReviewsResponse, error)

	// GetAnimeStaffWithResponse request
	GetAnimeStaffWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetAnimeStaffResponse, error)

	// GetAnimeStatisticsWithResponse request
	GetAnimeStatisticsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetAnimeStatisticsResponse, error)

	// GetAnimeStreamingWithResponse request
	GetAnimeStreamingWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetAnimeStreamingResponse, error)

	// GetAnimeThemesWithResponse request
	GetAnimeThemesWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetAnimeThemesResponse, error)

	// GetAnimeUserUpdatesWithResponse request
	GetAnimeUserUpdatesWithResponse(ctx context.Context, id int, params *GetAnimeUserUpdatesParams, reqEditors ...RequestEditorFn) (*GetAnimeUserUpdatesResponse, error)

	// GetAnimeVideosWithResponse request
	GetAnimeVideosWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetAnimeVideosResponse, error)

	// GetAnimeVideosEpisodesWithResponse request
	GetAnimeVideosEpisodesWithResponse(ctx context.Context, id int, params *GetAnimeVideosEpisodesParams, reqEditors ...RequestEditorFn) (*GetAnimeVideosEpisodesResponse, error)

	// GetCharactersSearchWithResponse request
	GetCharactersSearchWithResponse(ctx context.Context, params *GetCharactersSearchParams, reqEditors ...RequestEditorFn) (*GetCharactersSearchResponse, error)

	// GetCharacterByIdWithResponse request
	GetCharacterByIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetCharacterByIdResponse, error)

	// GetCharacterAnimeWithResponse request
	GetCharacterAnimeWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetCharacterAnimeResponse, error)

	// GetCharacterFullByIdWithResponse request
	GetCharacterFullByIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetCharacterFullByIdResponse, error)

	// GetCharacterMangaWithResponse request
	GetCharacterMangaWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetCharacterMangaResponse, error)

	// GetCharacterPicturesWithResponse request
	GetCharacterPicturesWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetCharacterPicturesResponse, error)

	// GetCharacterVoiceActorsWithResponse request
	GetCharacterVoiceActorsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetCharacterVoiceActorsResponse, error)

	// GetClubsSearchWithResponse request
	GetClubsSearchWithResponse(ctx context.Context, params *GetClubsSearchParams, reqEditors ...RequestEditorFn) (*GetClubsSearchResponse, error)

	// GetClubsByIdWithResponse request
	GetClubsByIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetClubsByIdResponse, error)

	// GetClubMembersWithResponse request
	GetClubMembersWithResponse(ctx context.Context, id int, params *GetClubMembersParams, reqEditors ...RequestEditorFn) (*GetClubMembersResponse, error)

	// GetClubRelationsWithResponse request
	GetClubRelationsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetClubRelationsResponse, error)

	// GetClubStaffWithResponse request
	GetClubStaffWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetClubStaffResponse, error)

	// GetAnimeGenresWithResponse request
	GetAnimeGenresWithResponse(ctx context.Context, params *GetAnimeGenresParams, reqEditors ...RequestEditorFn) (*GetAnimeGenresResponse, error)

	// GetMangaGenresWithResponse request
	GetMangaGenresWithResponse(ctx context.Context, params *GetMangaGenresParams, reqEditors ...RequestEditorFn) (*GetMangaGenresResponse, error)

	// GetMagazinesWithResponse request
	GetMagazinesWithResponse(ctx context.Context, params *GetMagazinesParams, reqEditors ...RequestEditorFn) (*GetMagazinesResponse, error)

	// GetMangaSearchWithResponse request
	GetMangaSearchWithResponse(ctx context.Context, params *GetMangaSearchParams, reqEditors ...RequestEditorFn) (*GetMangaSearchResponse, error)

	// GetMangaByIdWithResponse request
	GetMangaByIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetMangaByIdResponse, error)

	// GetMangaCharactersWithResponse request
	GetMangaCharactersWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetMangaCharactersResponse, error)

	// GetMangaExternalWithResponse request
	GetMangaExternalWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetMangaExternalResponse, error)

	// GetMangaTopicsWithResponse request
	GetMangaTopicsWithResponse(ctx context.Context, id int, params *GetMangaTopicsParams, reqEditors ...RequestEditorFn) (*GetMangaTopicsResponse, error)

	// GetMangaFullByIdWithResponse request
	GetMangaFullByIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetMangaFullByIdResponse, error)

	// GetMangaMoreInfoWithResponse request
	GetMangaMoreInfoWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetMangaMoreInfoResponse, error)

	// GetMangaNewsWithResponse request
	GetMangaNewsWithResponse(ctx context.Context, id int, params *GetMangaNewsParams, reqEditors ...RequestEditorFn) (*GetMangaNewsResponse, error)

	// GetMangaPicturesWithResponse request
	GetMangaPicturesWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetMangaPicturesResponse, error)

	// GetMangaRecommendationsWithResponse request
	GetMangaRecommendationsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetMangaRecommendationsResponse, error)

	// GetMangaRelationsWithResponse request
	GetMangaRelationsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetMangaRelationsResponse, error)

	// GetMangaReviewsWithResponse request
	GetMangaReviewsWithResponse(ctx context.Context, id int, params *GetMangaReviewsParams, reqEditors ...RequestEditorFn) (*GetMangaReviewsResponse, error)

	// GetMangaStatisticsWithResponse request
	GetMangaStatisticsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetMangaStatisticsResponse, error)

	// GetMangaUserUpdatesWithResponse request
	GetMangaUserUpdatesWithResponse(ctx context.Context, id int, params *GetMangaUserUpdatesParams, reqEditors ...RequestEditorFn) (*GetMangaUserUpdatesResponse, error)

	// GetPeopleSearchWithResponse request
	GetPeopleSearchWithResponse(ctx context.Context, params *GetPeopleSearchParams, reqEditors ...RequestEditorFn) (*GetPeopleSearchResponse, error)

	// GetPersonByIdWithResponse request
	GetPersonByIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetPersonByIdResponse, error)

	// GetPersonAnimeWithResponse request
	GetPersonAnimeWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetPersonAnimeResponse, error)

	// GetPersonFullByIdWithResponse request
	GetPersonFullByIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetPersonFullByIdResponse, error)

	// GetPersonMangaWithResponse request
	GetPersonMangaWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetPersonMangaResponse, error)

	// GetPersonPicturesWithResponse request
	GetPersonPicturesWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetPersonPicturesResponse, error)

	// GetPersonVoicesWithResponse request
	GetPersonVoicesWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetPersonVoicesResponse, error)

	// GetProducersWithResponse request
	GetProducersWithResponse(ctx context.Context, params *GetProducersParams, reqEditors ...RequestEditorFn) (*GetProducersResponse, error)

	// GetProducerByIdWithResponse request
	GetProducerByIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetProducerByIdResponse, error)

	// GetProducerExternalWithResponse request
	GetProducerExternalWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetProducerExternalResponse, error)

	// GetProducerFullByIdWithResponse request
	GetProducerFullByIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetProducerFullByIdResponse, error)

	// GetRandomAnimeWithResponse request
	GetRandomAnimeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRandomAnimeResponse, error)

	// GetRandomCharactersWithResponse request
	GetRandomCharactersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRandomCharactersResponse, error)

	// GetRandomMangaWithResponse request
	GetRandomMangaWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRandomMangaResponse, error)

	// GetRandomPeopleWithResponse request
	GetRandomPeopleWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRandomPeopleResponse, error)

	// GetRandomUsersWithResponse request
	GetRandomUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRandomUsersResponse, error)

	// GetRecentAnimeRecommendationsWithResponse request
	GetRecentAnimeRecommendationsWithResponse(ctx context.Context, params *GetRecentAnimeRecommendationsParams, reqEditors ...RequestEditorFn) (*GetRecentAnimeRecommendationsResponse, error)

	// GetRecentMangaRecommendationsWithResponse request
	GetRecentMangaRecommendationsWithResponse(ctx context.Context, params *GetRecentMangaRecommendationsParams, reqEditors ...RequestEditorFn) (*GetRecentMangaRecommendationsResponse, error)

	// GetRecentAnimeReviewsWithResponse request
	GetRecentAnimeReviewsWithResponse(ctx context.Context, params *GetRecentAnimeReviewsParams, reqEditors ...RequestEditorFn) (*GetRecentAnimeReviewsResponse, error)

	// GetRecentMangaReviewsWithResponse request
	GetRecentMangaReviewsWithResponse(ctx context.Context, params *GetRecentMangaReviewsParams, reqEditors ...RequestEditorFn) (*GetRecentMangaReviewsResponse, error)

	// GetSchedulesWithResponse request
	GetSchedulesWithResponse(ctx context.Context, params *GetSchedulesParams, reqEditors ...RequestEditorFn) (*GetSchedulesResponse, error)

	// GetSeasonsListWithResponse request
	GetSeasonsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSeasonsListResponse, error)

	// GetSeasonNowWithResponse request
	GetSeasonNowWithResponse(ctx context.Context, params *GetSeasonNowParams, reqEditors ...RequestEditorFn) (*GetSeasonNowResponse, error)

	// GetSeasonUpcomingWithResponse request
	GetSeasonUpcomingWithResponse(ctx context.Context, params *GetSeasonUpcomingParams, reqEditors ...RequestEditorFn) (*GetSeasonUpcomingResponse, error)

	// GetSeasonWithResponse request
	GetSeasonWithResponse(ctx context.Context, year int, season string, params *GetSeasonParams, reqEditors ...RequestEditorFn) (*GetSeasonResponse, error)

	// GetTopAnimeWithResponse request
	GetTopAnimeWithResponse(ctx context.Context, params *GetTopAnimeParams, reqEditors ...RequestEditorFn) (*GetTopAnimeResponse, error)

	// GetTopCharactersWithResponse request
	GetTopCharactersWithResponse(ctx context.Context, params *GetTopCharactersParams, reqEditors ...RequestEditorFn) (*GetTopCharactersResponse, error)

	// GetTopMangaWithResponse request
	GetTopMangaWithResponse(ctx context.Context, params *GetTopMangaParams, reqEditors ...RequestEditorFn) (*GetTopMangaResponse, error)

	// GetTopPeopleWithResponse request
	GetTopPeopleWithResponse(ctx context.Context, params *GetTopPeopleParams, reqEditors ...RequestEditorFn) (*GetTopPeopleResponse, error)

	// GetTopReviewsWithResponse request
	GetTopReviewsWithResponse(ctx context.Context, params *GetTopReviewsParams, reqEditors ...RequestEditorFn) (*GetTopReviewsResponse, error)

	// GetUsersSearchWithResponse request
	GetUsersSearchWithResponse(ctx context.Context, params *GetUsersSearchParams, reqEditors ...RequestEditorFn) (*GetUsersSearchResponse, error)

	// GetUserByIdWithResponse request
	GetUserByIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetUserByIdResponse, error)

	// GetUserProfileWithResponse request
	GetUserProfileWithResponse(ctx context.Context, username string, reqEditors ...RequestEditorFn) (*GetUserProfileResponse, error)

	// GetUserAboutWithResponse request
	GetUserAboutWithResponse(ctx context.Context, username string, reqEditors ...RequestEditorFn) (*GetUserAboutResponse, error)

	// GetUserAnimelistWithResponse request
	GetUserAnimelistWithResponse(ctx context.Context, username string, params *GetUserAnimelistParams, reqEditors ...RequestEditorFn) (*GetUserAnimelistResponse, error)

	// GetUserClubsWithResponse request
	GetUserClubsWithResponse(ctx context.Context, username string, params *GetUserClubsParams, reqEditors ...RequestEditorFn) (*GetUserClubsResponse, error)

	// GetUserExternalWithResponse request
	GetUserExternalWithResponse(ctx context.Context, username string, reqEditors ...RequestEditorFn) (*GetUserExternalResponse, error)

	// GetUserFavoritesWithResponse request
	GetUserFavoritesWithResponse(ctx context.Context, username string, reqEditors ...RequestEditorFn) (*GetUserFavoritesResponse, error)

	// GetUserFriendsWithResponse request
	GetUserFriendsWithResponse(ctx context.Context, username string, params *GetUserFriendsParams, reqEditors ...RequestEditorFn) (*GetUserFriendsResponse, error)

	// GetUserFullProfileWithResponse request
	GetUserFullProfileWithResponse(ctx context.Context, username string, reqEditors ...RequestEditorFn) (*GetUserFullProfileResponse, error)

	// GetUserHistoryWithResponse request
	GetUserHistoryWithResponse(ctx context.Context, username string, params *GetUserHistoryParams, reqEditors ...RequestEditorFn) (*GetUserHistoryResponse, error)

	// GetUserMangaListWithResponse request
	GetUserMangaListWithResponse(ctx context.Context, username string, params *GetUserMangaListParams, reqEditors ...RequestEditorFn) (*GetUserMangaListResponse, error)

	// GetUserRecommendationsWithResponse request
	GetUserRecommendationsWithResponse(ctx context.Context, username string, params *GetUserRecommendationsParams, reqEditors ...RequestEditorFn) (*GetUserRecommendationsResponse, error)

	// GetUserReviewsWithResponse request
	GetUserReviewsWithResponse(ctx context.Context, username string, params *GetUserReviewsParams, reqEditors ...RequestEditorFn) (*GetUserReviewsResponse, error)

	// GetUserStatisticsWithResponse request
	GetUserStatisticsWithResponse(ctx context.Context, username string, reqEditors ...RequestEditorFn) (*GetUserStatisticsResponse, error)

	// GetUserUpdatesWithResponse request
	GetUserUpdatesWithResponse(ctx context.Context, username string, reqEditors ...RequestEditorFn) (*GetUserUpdatesResponse, error)

	// GetWatchRecentEpisodesWithResponse request
	GetWatchRecentEpisodesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWatchRecentEpisodesResponse, error)

	// GetWatchPopularEpisodesWithResponse request
	GetWatchPopularEpisodesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWatchPopularEpisodesResponse, error)

	// GetWatchRecentPromosWithResponse request
	GetWatchRecentPromosWithResponse(ctx context.Context, params *GetWatchRecentPromosParams, reqEditors ...RequestEditorFn) (*GetWatchRecentPromosResponse, error)

	// GetWatchPopularPromosWithResponse request
	GetWatchPopularPromosWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWatchPopularPromosResponse, error)
}

type GetAnimeSearchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AnimeSearch
}

// Status returns HTTPResponse.Status
func (r GetAnimeSearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnimeSearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnimeByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Anime Resource
		Data *Anime `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAnimeByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnimeByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnimeCharactersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AnimeCharacters
}

// Status returns HTTPResponse.Status
func (r GetAnimeCharactersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnimeCharactersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnimeEpisodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AnimeEpisodes
}

// Status returns HTTPResponse.Status
func (r GetAnimeEpisodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnimeEpisodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnimeEpisodeByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Anime Episode Resource
		Data *AnimeEpisode `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAnimeEpisodeByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnimeEpisodeByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnimeExternalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExternalLinks
}

// Status returns HTTPResponse.Status
func (r GetAnimeExternalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnimeExternalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnimeForumResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Forum
}

// Status returns HTTPResponse.Status
func (r GetAnimeForumResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnimeForumResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnimeFullByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Full anime Resource
		Data *AnimeFull `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAnimeFullByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnimeFullByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnimeMoreInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Moreinfo
}

// Status returns HTTPResponse.Status
func (r GetAnimeMoreInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnimeMoreInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnimeNewsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AnimeNews
}

// Status returns HTTPResponse.Status
func (r GetAnimeNewsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnimeNewsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnimePicturesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PicturesVariants
}

// Status returns HTTPResponse.Status
func (r GetAnimePicturesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnimePicturesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnimeRecommendationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntryRecommendations
}

// Status returns HTTPResponse.Status
func (r GetAnimeRecommendationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnimeRecommendationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnimeRelationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]Relation `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAnimeRelationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnimeRelationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnimeReviewsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AnimeReviews
}

// Status returns HTTPResponse.Status
func (r GetAnimeReviewsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnimeReviewsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnimeStaffResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AnimeStaff
}

// Status returns HTTPResponse.Status
func (r GetAnimeStaffResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnimeStaffResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnimeStatisticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AnimeStatistics
}

// Status returns HTTPResponse.Status
func (r GetAnimeStatisticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnimeStatisticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnimeStreamingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExternalLinks
}

// Status returns HTTPResponse.Status
func (r GetAnimeStreamingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnimeStreamingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnimeThemesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AnimeThemes
}

// Status returns HTTPResponse.Status
func (r GetAnimeThemesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnimeThemesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnimeUserUpdatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AnimeUserupdates
}

// Status returns HTTPResponse.Status
func (r GetAnimeUserUpdatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnimeUserUpdatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnimeVideosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AnimeVideos
}

// Status returns HTTPResponse.Status
func (r GetAnimeVideosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnimeVideosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnimeVideosEpisodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AnimeVideosEpisodes
}

// Status returns HTTPResponse.Status
func (r GetAnimeVideosEpisodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnimeVideosEpisodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCharactersSearchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CharactersSearch
}

// Status returns HTTPResponse.Status
func (r GetCharactersSearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCharactersSearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCharacterByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Character Resource
		Data *Character `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCharacterByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCharacterByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCharacterAnimeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CharacterAnime
}

// Status returns HTTPResponse.Status
func (r GetCharacterAnimeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCharacterAnimeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCharacterFullByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Character Resource
		Data *CharacterFull `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCharacterFullByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCharacterFullByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCharacterMangaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CharacterManga
}

// Status returns HTTPResponse.Status
func (r GetCharacterMangaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCharacterMangaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCharacterPicturesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CharacterPictures
}

// Status returns HTTPResponse.Status
func (r GetCharacterPicturesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCharacterPicturesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCharacterVoiceActorsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CharacterVoiceActors
}

// Status returns HTTPResponse.Status
func (r GetCharacterVoiceActorsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCharacterVoiceActorsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClubsSearchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClubsSearch
}

// Status returns HTTPResponse.Status
func (r GetClubsSearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClubsSearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClubsByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Club Resource
		Data *Club `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetClubsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClubsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClubMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			Images *UserImages `json:"images,omitempty"`

			// Url User URL
			Url *string `json:"url,omitempty"`

			// Username User's username
			Username *string `json:"username,omitempty"`
		} `json:"data,omitempty"`
		Pagination *struct {
			HasNextPage     *bool `json:"has_next_page,omitempty"`
			LastVisiblePage *int  `json:"last_visible_page,omitempty"`
		} `json:"pagination,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetClubMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClubMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClubRelationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClubRelations
}

// Status returns HTTPResponse.Status
func (r GetClubRelationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClubRelationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClubStaffResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ClubStaff
}

// Status returns HTTPResponse.Status
func (r GetClubStaffResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClubStaffResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAnimeGenresResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Genres
}

// Status returns HTTPResponse.Status
func (r GetAnimeGenresResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAnimeGenresResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMangaGenresResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Genres
}

// Status returns HTTPResponse.Status
func (r GetMangaGenresResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMangaGenresResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMagazinesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Magazines
}

// Status returns HTTPResponse.Status
func (r GetMagazinesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMagazinesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMangaSearchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MangaSearch
}

// Status returns HTTPResponse.Status
func (r GetMangaSearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMangaSearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMangaByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Manga Resource
		Data *Manga `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetMangaByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMangaByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMangaCharactersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MangaCharacters
}

// Status returns HTTPResponse.Status
func (r GetMangaCharactersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMangaCharactersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMangaExternalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExternalLinks
}

// Status returns HTTPResponse.Status
func (r GetMangaExternalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMangaExternalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMangaTopicsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Forum
}

// Status returns HTTPResponse.Status
func (r GetMangaTopicsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMangaTopicsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMangaFullByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Manga Resource
		Data *MangaFull `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetMangaFullByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMangaFullByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMangaMoreInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Moreinfo
}

// Status returns HTTPResponse.Status
func (r GetMangaMoreInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMangaMoreInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMangaNewsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MangaNews
}

// Status returns HTTPResponse.Status
func (r GetMangaNewsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMangaNewsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMangaPicturesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MangaPictures
}

// Status returns HTTPResponse.Status
func (r GetMangaPicturesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMangaPicturesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMangaRecommendationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *EntryRecommendations
}

// Status returns HTTPResponse.Status
func (r GetMangaRecommendationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMangaRecommendationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMangaRelationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]Relation `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetMangaRelationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMangaRelationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMangaReviewsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MangaReviews
}

// Status returns HTTPResponse.Status
func (r GetMangaReviewsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMangaReviewsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMangaStatisticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MangaStatistics
}

// Status returns HTTPResponse.Status
func (r GetMangaStatisticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMangaStatisticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMangaUserUpdatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MangaUserupdates
}

// Status returns HTTPResponse.Status
func (r GetMangaUserUpdatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMangaUserUpdatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPeopleSearchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PeopleSearch
}

// Status returns HTTPResponse.Status
func (r GetPeopleSearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPeopleSearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersonByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Person Resource
		Data *Person `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPersonByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersonByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersonAnimeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PersonAnime
}

// Status returns HTTPResponse.Status
func (r GetPersonAnimeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersonAnimeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersonFullByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Person Resource
		Data *PersonFull `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPersonFullByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersonFullByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersonMangaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PersonManga
}

// Status returns HTTPResponse.Status
func (r GetPersonMangaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersonMangaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersonPicturesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PersonPictures
}

// Status returns HTTPResponse.Status
func (r GetPersonPicturesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersonPicturesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPersonVoicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PersonVoiceActingRoles
}

// Status returns HTTPResponse.Status
func (r GetPersonVoicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPersonVoicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProducersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Producers
}

// Status returns HTTPResponse.Status
func (r GetProducersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProducersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProducerByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Producers Resource
		Data *Producer `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetProducerByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProducerByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProducerExternalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExternalLinks
}

// Status returns HTTPResponse.Status
func (r GetProducerExternalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProducerExternalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProducerFullByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Producers Resource
		Data *ProducerFull `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetProducerFullByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProducerFullByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRandomAnimeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Anime Resource
		Data *Anime `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRandomAnimeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRandomAnimeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRandomCharactersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Character Resource
		Data *Character `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRandomCharactersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRandomCharactersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRandomMangaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Manga Resource
		Data *Manga `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRandomMangaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRandomMangaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRandomPeopleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Person Resource
		Data *Person `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRandomPeopleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRandomPeopleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRandomUsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *UserProfile `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetRandomUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRandomUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecentAnimeRecommendationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Recommendations
}

// Status returns HTTPResponse.Status
func (r GetRecentAnimeRecommendationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecentAnimeRecommendationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecentMangaRecommendationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Recommendations
}

// Status returns HTTPResponse.Status
func (r GetRecentMangaRecommendationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecentMangaRecommendationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecentAnimeReviewsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r GetRecentAnimeReviewsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecentAnimeReviewsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRecentMangaReviewsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r GetRecentMangaReviewsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRecentMangaReviewsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSchedulesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Schedules
}

// Status returns HTTPResponse.Status
func (r GetSchedulesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSchedulesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSeasonsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Seasons
}

// Status returns HTTPResponse.Status
func (r GetSeasonsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSeasonsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSeasonNowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AnimeSearch
}

// Status returns HTTPResponse.Status
func (r GetSeasonNowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSeasonNowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSeasonUpcomingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AnimeSearch
}

// Status returns HTTPResponse.Status
func (r GetSeasonUpcomingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSeasonUpcomingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSeasonResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AnimeSearch
}

// Status returns HTTPResponse.Status
func (r GetSeasonResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSeasonResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTopAnimeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AnimeSearch
}

// Status returns HTTPResponse.Status
func (r GetTopAnimeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTopAnimeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTopCharactersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CharactersSearch
}

// Status returns HTTPResponse.Status
func (r GetTopCharactersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTopCharactersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTopMangaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MangaSearch
}

// Status returns HTTPResponse.Status
func (r GetTopMangaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTopMangaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTopPeopleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PeopleSearch
}

// Status returns HTTPResponse.Status
func (r GetTopPeopleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTopPeopleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTopReviewsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Data       *[]GetTopReviews_200_Data_Data_Item `json:"data,omitempty"`
			Pagination *struct {
				HasNextPage     *bool `json:"has_next_page,omitempty"`
				LastVisiblePage *int  `json:"last_visible_page,omitempty"`
			} `json:"pagination,omitempty"`
		} `json:"data,omitempty"`
	}
}
type GetTopReviews200DataData0 struct {
	Anime *AnimeMeta `json:"anime,omitempty"`

	// Date Review created date ISO8601
	Date *string `json:"date,omitempty"`

	// EpisodesWatched Number of episodes watched
	EpisodesWatched *int `json:"episodes_watched,omitempty"`

	// IsPreliminary The review was made before the entry was completed
	IsPreliminary *bool `json:"is_preliminary,omitempty"`

	// IsSpoiler The review contains spoiler
	IsSpoiler *bool `json:"is_spoiler,omitempty"`

	// MalId MyAnimeList ID
	MalId *int `json:"mal_id,omitempty"`

	// Reactions User reaction count on the review
	Reactions *struct {
		// Confusing Confusing reaction count
		Confusing *int `json:"confusing,omitempty"`

		// Creative Creative reaction count
		Creative *int `json:"creative,omitempty"`

		// Funny Funny reaction count
		Funny *int `json:"funny,omitempty"`

		// Informative Informative reaction count
		Informative *int `json:"informative,omitempty"`

		// LoveIt Love it reaction count
		LoveIt *int `json:"love_it,omitempty"`

		// Nice Nice reaction count
		Nice *int `json:"nice,omitempty"`

		// Overall Overall reaction count
		Overall *int `json:"overall,omitempty"`

		// WellWritten Well written reaction count
		WellWritten *int `json:"well_written,omitempty"`
	} `json:"reactions,omitempty"`

	// Review Review content
	Review *string `json:"review,omitempty"`

	// Score Number of user votes on the Review
	Score *int `json:"score,omitempty"`

	// Tags Review tags
	Tags *[]string `json:"tags,omitempty"`

	// Type Entry type
	Type *string `json:"type,omitempty"`

	// Url MyAnimeList review URL
	Url  *string   `json:"url,omitempty"`
	User *UserMeta `json:"user,omitempty"`
}
type GetTopReviews200DataData1 struct {
	// Date Review created date ISO8601
	Date *string `json:"date,omitempty"`

	// IsPreliminary The review was made before the entry was completed
	IsPreliminary *bool `json:"is_preliminary,omitempty"`

	// IsSpoiler The review contains spoiler
	IsSpoiler *bool `json:"is_spoiler,omitempty"`

	// MalId MyAnimeList ID
	MalId *int       `json:"mal_id,omitempty"`
	Manga *MangaMeta `json:"manga,omitempty"`

	// Reactions User reaction count on the review
	Reactions *struct {
		// Confusing Confusing reaction count
		Confusing *int `json:"confusing,omitempty"`

		// Creative Creative reaction count
		Creative *int `json:"creative,omitempty"`

		// Funny Funny reaction count
		Funny *int `json:"funny,omitempty"`

		// Informative Informative reaction count
		Informative *int `json:"informative,omitempty"`

		// LoveIt Love it reaction count
		LoveIt *int `json:"love_it,omitempty"`

		// Nice Nice reaction count
		Nice *int `json:"nice,omitempty"`

		// Overall Overall reaction count
		Overall *int `json:"overall,omitempty"`

		// WellWritten Well written reaction count
		WellWritten *int `json:"well_written,omitempty"`
	} `json:"reactions,omitempty"`

	// Review Review content
	Review *string `json:"review,omitempty"`

	// Score Number of user votes on the Review
	Score *int `json:"score,omitempty"`

	// Tags Review tags
	Tags *[]string `json:"tags,omitempty"`

	// Type Entry type
	Type *string `json:"type,omitempty"`

	// Url MyAnimeList review URL
	Url  *string   `json:"url,omitempty"`
	User *UserMeta `json:"user,omitempty"`
}
type GetTopReviews_200_Data_Data_Item struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r GetTopReviewsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTopReviewsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersSearchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UsersSearch
}

// Status returns HTTPResponse.Status
func (r GetUsersSearchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersSearchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data User Meta By ID
		Data *UserById `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetUserByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *UserProfile `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetUserProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserAboutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserAbout
}

// Status returns HTTPResponse.Status
func (r GetUserAboutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserAboutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserAnimelistResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r GetUserAnimelistResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserAnimelistResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserClubsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserClubs
}

// Status returns HTTPResponse.Status
func (r GetUserClubsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserClubsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserExternalResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExternalLinks
}

// Status returns HTTPResponse.Status
func (r GetUserExternalResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserExternalResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserFavoritesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *UserFavorites `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetUserFavoritesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserFavoritesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserFriendsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserFriends
}

// Status returns HTTPResponse.Status
func (r GetUserFriendsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserFriendsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserFullProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Data Transform the resource into an array.
		Data *UserProfileFull `json:"data,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetUserFullProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserFullProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserHistory
}

// Status returns HTTPResponse.Status
func (r GetUserHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserMangaListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *interface{}
}

// Status returns HTTPResponse.Status
func (r GetUserMangaListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserMangaListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserRecommendationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Recommendations
}

// Status returns HTTPResponse.Status
func (r GetUserRecommendationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserRecommendationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserReviewsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *struct {
			Data       *[]GetUserReviews_200_Data_Data_Item `json:"data,omitempty"`
			Pagination *struct {
				HasNextPage     *bool `json:"has_next_page,omitempty"`
				LastVisiblePage *int  `json:"last_visible_page,omitempty"`
			} `json:"pagination,omitempty"`
		} `json:"data,omitempty"`
	}
}
type GetUserReviews200DataData0 struct {
	Anime *AnimeMeta `json:"anime,omitempty"`

	// Date Review created date ISO8601
	Date *string `json:"date,omitempty"`

	// EpisodesWatched Number of episodes watched
	EpisodesWatched *int `json:"episodes_watched,omitempty"`

	// IsPreliminary The review was made before the entry was completed
	IsPreliminary *bool `json:"is_preliminary,omitempty"`

	// IsSpoiler The review contains spoiler
	IsSpoiler *bool `json:"is_spoiler,omitempty"`

	// MalId MyAnimeList ID
	MalId *int `json:"mal_id,omitempty"`

	// Reactions User reaction count on the review
	Reactions *struct {
		// Confusing Confusing reaction count
		Confusing *int `json:"confusing,omitempty"`

		// Creative Creative reaction count
		Creative *int `json:"creative,omitempty"`

		// Funny Funny reaction count
		Funny *int `json:"funny,omitempty"`

		// Informative Informative reaction count
		Informative *int `json:"informative,omitempty"`

		// LoveIt Love it reaction count
		LoveIt *int `json:"love_it,omitempty"`

		// Nice Nice reaction count
		Nice *int `json:"nice,omitempty"`

		// Overall Overall reaction count
		Overall *int `json:"overall,omitempty"`

		// WellWritten Well written reaction count
		WellWritten *int `json:"well_written,omitempty"`
	} `json:"reactions,omitempty"`

	// Review Review content
	Review *string `json:"review,omitempty"`

	// Score Number of user votes on the Review
	Score *int `json:"score,omitempty"`

	// Tags Review tags
	Tags *[]string `json:"tags,omitempty"`

	// Type Entry type
	Type *string `json:"type,omitempty"`

	// Url MyAnimeList review URL
	Url  *string   `json:"url,omitempty"`
	User *UserMeta `json:"user,omitempty"`
}
type GetUserReviews200DataData1 struct {
	// Date Review created date ISO8601
	Date *string `json:"date,omitempty"`

	// IsPreliminary The review was made before the entry was completed
	IsPreliminary *bool `json:"is_preliminary,omitempty"`

	// IsSpoiler The review contains spoiler
	IsSpoiler *bool `json:"is_spoiler,omitempty"`

	// MalId MyAnimeList ID
	MalId *int       `json:"mal_id,omitempty"`
	Manga *MangaMeta `json:"manga,omitempty"`

	// Reactions User reaction count on the review
	Reactions *struct {
		// Confusing Confusing reaction count
		Confusing *int `json:"confusing,omitempty"`

		// Creative Creative reaction count
		Creative *int `json:"creative,omitempty"`

		// Funny Funny reaction count
		Funny *int `json:"funny,omitempty"`

		// Informative Informative reaction count
		Informative *int `json:"informative,omitempty"`

		// LoveIt Love it reaction count
		LoveIt *int `json:"love_it,omitempty"`

		// Nice Nice reaction count
		Nice *int `json:"nice,omitempty"`

		// Overall Overall reaction count
		Overall *int `json:"overall,omitempty"`

		// WellWritten Well written reaction count
		WellWritten *int `json:"well_written,omitempty"`
	} `json:"reactions,omitempty"`

	// Review Review content
	Review *string `json:"review,omitempty"`

	// Score Number of user votes on the Review
	Score *int `json:"score,omitempty"`

	// Tags Review tags
	Tags *[]string `json:"tags,omitempty"`

	// Type Entry type
	Type *string `json:"type,omitempty"`

	// Url MyAnimeList review URL
	Url  *string   `json:"url,omitempty"`
	User *UserMeta `json:"user,omitempty"`
}
type GetUserReviews_200_Data_Data_Item struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r GetUserReviewsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserReviewsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserStatisticsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserStatistics
}

// Status returns HTTPResponse.Status
func (r GetUserStatisticsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserStatisticsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserUpdatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserUpdates
}

// Status returns HTTPResponse.Status
func (r GetUserUpdatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserUpdatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWatchRecentEpisodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WatchEpisodes
}

// Status returns HTTPResponse.Status
func (r GetWatchRecentEpisodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWatchRecentEpisodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWatchPopularEpisodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WatchEpisodes
}

// Status returns HTTPResponse.Status
func (r GetWatchPopularEpisodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWatchPopularEpisodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWatchRecentPromosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WatchPromos
}

// Status returns HTTPResponse.Status
func (r GetWatchRecentPromosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWatchRecentPromosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWatchPopularPromosResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WatchPromos
}

// Status returns HTTPResponse.Status
func (r GetWatchPopularPromosResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWatchPopularPromosResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAnimeSearchWithResponse request returning *GetAnimeSearchResponse
func (c *ClientWithResponses) GetAnimeSearchWithResponse(ctx context.Context, params *GetAnimeSearchParams, reqEditors ...RequestEditorFn) (*GetAnimeSearchResponse, error) {
	rsp, err := c.GetAnimeSearch(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnimeSearchResponse(rsp)
}

// GetAnimeByIdWithResponse request returning *GetAnimeByIdResponse
func (c *ClientWithResponses) GetAnimeByIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetAnimeByIdResponse, error) {
	rsp, err := c.GetAnimeById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnimeByIdResponse(rsp)
}

// GetAnimeCharactersWithResponse request returning *GetAnimeCharactersResponse
func (c *ClientWithResponses) GetAnimeCharactersWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetAnimeCharactersResponse, error) {
	rsp, err := c.GetAnimeCharacters(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnimeCharactersResponse(rsp)
}

// GetAnimeEpisodesWithResponse request returning *GetAnimeEpisodesResponse
func (c *ClientWithResponses) GetAnimeEpisodesWithResponse(ctx context.Context, id int, params *GetAnimeEpisodesParams, reqEditors ...RequestEditorFn) (*GetAnimeEpisodesResponse, error) {
	rsp, err := c.GetAnimeEpisodes(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnimeEpisodesResponse(rsp)
}

// GetAnimeEpisodeByIdWithResponse request returning *GetAnimeEpisodeByIdResponse
func (c *ClientWithResponses) GetAnimeEpisodeByIdWithResponse(ctx context.Context, id int, episode int, reqEditors ...RequestEditorFn) (*GetAnimeEpisodeByIdResponse, error) {
	rsp, err := c.GetAnimeEpisodeById(ctx, id, episode, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnimeEpisodeByIdResponse(rsp)
}

// GetAnimeExternalWithResponse request returning *GetAnimeExternalResponse
func (c *ClientWithResponses) GetAnimeExternalWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetAnimeExternalResponse, error) {
	rsp, err := c.GetAnimeExternal(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnimeExternalResponse(rsp)
}

// GetAnimeForumWithResponse request returning *GetAnimeForumResponse
func (c *ClientWithResponses) GetAnimeForumWithResponse(ctx context.Context, id int, params *GetAnimeForumParams, reqEditors ...RequestEditorFn) (*GetAnimeForumResponse, error) {
	rsp, err := c.GetAnimeForum(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnimeForumResponse(rsp)
}

// GetAnimeFullByIdWithResponse request returning *GetAnimeFullByIdResponse
func (c *ClientWithResponses) GetAnimeFullByIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetAnimeFullByIdResponse, error) {
	rsp, err := c.GetAnimeFullById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnimeFullByIdResponse(rsp)
}

// GetAnimeMoreInfoWithResponse request returning *GetAnimeMoreInfoResponse
func (c *ClientWithResponses) GetAnimeMoreInfoWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetAnimeMoreInfoResponse, error) {
	rsp, err := c.GetAnimeMoreInfo(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnimeMoreInfoResponse(rsp)
}

// GetAnimeNewsWithResponse request returning *GetAnimeNewsResponse
func (c *ClientWithResponses) GetAnimeNewsWithResponse(ctx context.Context, id int, params *GetAnimeNewsParams, reqEditors ...RequestEditorFn) (*GetAnimeNewsResponse, error) {
	rsp, err := c.GetAnimeNews(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnimeNewsResponse(rsp)
}

// GetAnimePicturesWithResponse request returning *GetAnimePicturesResponse
func (c *ClientWithResponses) GetAnimePicturesWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetAnimePicturesResponse, error) {
	rsp, err := c.GetAnimePictures(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnimePicturesResponse(rsp)
}

// GetAnimeRecommendationsWithResponse request returning *GetAnimeRecommendationsResponse
func (c *ClientWithResponses) GetAnimeRecommendationsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetAnimeRecommendationsResponse, error) {
	rsp, err := c.GetAnimeRecommendations(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnimeRecommendationsResponse(rsp)
}

// GetAnimeRelationsWithResponse request returning *GetAnimeRelationsResponse
func (c *ClientWithResponses) GetAnimeRelationsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetAnimeRelationsResponse, error) {
	rsp, err := c.GetAnimeRelations(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnimeRelationsResponse(rsp)
}

// GetAnimeReviewsWithResponse request returning *GetAnimeReviewsResponse
func (c *ClientWithResponses) GetAnimeReviewsWithResponse(ctx context.Context, id int, params *GetAnimeReviewsParams, reqEditors ...RequestEditorFn) (*GetAnimeReviewsResponse, error) {
	rsp, err := c.GetAnimeReviews(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnimeReviewsResponse(rsp)
}

// GetAnimeStaffWithResponse request returning *GetAnimeStaffResponse
func (c *ClientWithResponses) GetAnimeStaffWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetAnimeStaffResponse, error) {
	rsp, err := c.GetAnimeStaff(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnimeStaffResponse(rsp)
}

// GetAnimeStatisticsWithResponse request returning *GetAnimeStatisticsResponse
func (c *ClientWithResponses) GetAnimeStatisticsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetAnimeStatisticsResponse, error) {
	rsp, err := c.GetAnimeStatistics(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnimeStatisticsResponse(rsp)
}

// GetAnimeStreamingWithResponse request returning *GetAnimeStreamingResponse
func (c *ClientWithResponses) GetAnimeStreamingWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetAnimeStreamingResponse, error) {
	rsp, err := c.GetAnimeStreaming(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnimeStreamingResponse(rsp)
}

// GetAnimeThemesWithResponse request returning *GetAnimeThemesResponse
func (c *ClientWithResponses) GetAnimeThemesWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetAnimeThemesResponse, error) {
	rsp, err := c.GetAnimeThemes(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnimeThemesResponse(rsp)
}

// GetAnimeUserUpdatesWithResponse request returning *GetAnimeUserUpdatesResponse
func (c *ClientWithResponses) GetAnimeUserUpdatesWithResponse(ctx context.Context, id int, params *GetAnimeUserUpdatesParams, reqEditors ...RequestEditorFn) (*GetAnimeUserUpdatesResponse, error) {
	rsp, err := c.GetAnimeUserUpdates(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnimeUserUpdatesResponse(rsp)
}

// GetAnimeVideosWithResponse request returning *GetAnimeVideosResponse
func (c *ClientWithResponses) GetAnimeVideosWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetAnimeVideosResponse, error) {
	rsp, err := c.GetAnimeVideos(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnimeVideosResponse(rsp)
}

// GetAnimeVideosEpisodesWithResponse request returning *GetAnimeVideosEpisodesResponse
func (c *ClientWithResponses) GetAnimeVideosEpisodesWithResponse(ctx context.Context, id int, params *GetAnimeVideosEpisodesParams, reqEditors ...RequestEditorFn) (*GetAnimeVideosEpisodesResponse, error) {
	rsp, err := c.GetAnimeVideosEpisodes(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnimeVideosEpisodesResponse(rsp)
}

// GetCharactersSearchWithResponse request returning *GetCharactersSearchResponse
func (c *ClientWithResponses) GetCharactersSearchWithResponse(ctx context.Context, params *GetCharactersSearchParams, reqEditors ...RequestEditorFn) (*GetCharactersSearchResponse, error) {
	rsp, err := c.GetCharactersSearch(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCharactersSearchResponse(rsp)
}

// GetCharacterByIdWithResponse request returning *GetCharacterByIdResponse
func (c *ClientWithResponses) GetCharacterByIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetCharacterByIdResponse, error) {
	rsp, err := c.GetCharacterById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCharacterByIdResponse(rsp)
}

// GetCharacterAnimeWithResponse request returning *GetCharacterAnimeResponse
func (c *ClientWithResponses) GetCharacterAnimeWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetCharacterAnimeResponse, error) {
	rsp, err := c.GetCharacterAnime(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCharacterAnimeResponse(rsp)
}

// GetCharacterFullByIdWithResponse request returning *GetCharacterFullByIdResponse
func (c *ClientWithResponses) GetCharacterFullByIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetCharacterFullByIdResponse, error) {
	rsp, err := c.GetCharacterFullById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCharacterFullByIdResponse(rsp)
}

// GetCharacterMangaWithResponse request returning *GetCharacterMangaResponse
func (c *ClientWithResponses) GetCharacterMangaWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetCharacterMangaResponse, error) {
	rsp, err := c.GetCharacterManga(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCharacterMangaResponse(rsp)
}

// GetCharacterPicturesWithResponse request returning *GetCharacterPicturesResponse
func (c *ClientWithResponses) GetCharacterPicturesWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetCharacterPicturesResponse, error) {
	rsp, err := c.GetCharacterPictures(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCharacterPicturesResponse(rsp)
}

// GetCharacterVoiceActorsWithResponse request returning *GetCharacterVoiceActorsResponse
func (c *ClientWithResponses) GetCharacterVoiceActorsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetCharacterVoiceActorsResponse, error) {
	rsp, err := c.GetCharacterVoiceActors(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCharacterVoiceActorsResponse(rsp)
}

// GetClubsSearchWithResponse request returning *GetClubsSearchResponse
func (c *ClientWithResponses) GetClubsSearchWithResponse(ctx context.Context, params *GetClubsSearchParams, reqEditors ...RequestEditorFn) (*GetClubsSearchResponse, error) {
	rsp, err := c.GetClubsSearch(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClubsSearchResponse(rsp)
}

// GetClubsByIdWithResponse request returning *GetClubsByIdResponse
func (c *ClientWithResponses) GetClubsByIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetClubsByIdResponse, error) {
	rsp, err := c.GetClubsById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClubsByIdResponse(rsp)
}

// GetClubMembersWithResponse request returning *GetClubMembersResponse
func (c *ClientWithResponses) GetClubMembersWithResponse(ctx context.Context, id int, params *GetClubMembersParams, reqEditors ...RequestEditorFn) (*GetClubMembersResponse, error) {
	rsp, err := c.GetClubMembers(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClubMembersResponse(rsp)
}

// GetClubRelationsWithResponse request returning *GetClubRelationsResponse
func (c *ClientWithResponses) GetClubRelationsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetClubRelationsResponse, error) {
	rsp, err := c.GetClubRelations(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClubRelationsResponse(rsp)
}

// GetClubStaffWithResponse request returning *GetClubStaffResponse
func (c *ClientWithResponses) GetClubStaffWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetClubStaffResponse, error) {
	rsp, err := c.GetClubStaff(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClubStaffResponse(rsp)
}

// GetAnimeGenresWithResponse request returning *GetAnimeGenresResponse
func (c *ClientWithResponses) GetAnimeGenresWithResponse(ctx context.Context, params *GetAnimeGenresParams, reqEditors ...RequestEditorFn) (*GetAnimeGenresResponse, error) {
	rsp, err := c.GetAnimeGenres(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAnimeGenresResponse(rsp)
}

// GetMangaGenresWithResponse request returning *GetMangaGenresResponse
func (c *ClientWithResponses) GetMangaGenresWithResponse(ctx context.Context, params *GetMangaGenresParams, reqEditors ...RequestEditorFn) (*GetMangaGenresResponse, error) {
	rsp, err := c.GetMangaGenres(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMangaGenresResponse(rsp)
}

// GetMagazinesWithResponse request returning *GetMagazinesResponse
func (c *ClientWithResponses) GetMagazinesWithResponse(ctx context.Context, params *GetMagazinesParams, reqEditors ...RequestEditorFn) (*GetMagazinesResponse, error) {
	rsp, err := c.GetMagazines(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMagazinesResponse(rsp)
}

// GetMangaSearchWithResponse request returning *GetMangaSearchResponse
func (c *ClientWithResponses) GetMangaSearchWithResponse(ctx context.Context, params *GetMangaSearchParams, reqEditors ...RequestEditorFn) (*GetMangaSearchResponse, error) {
	rsp, err := c.GetMangaSearch(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMangaSearchResponse(rsp)
}

// GetMangaByIdWithResponse request returning *GetMangaByIdResponse
func (c *ClientWithResponses) GetMangaByIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetMangaByIdResponse, error) {
	rsp, err := c.GetMangaById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMangaByIdResponse(rsp)
}

// GetMangaCharactersWithResponse request returning *GetMangaCharactersResponse
func (c *ClientWithResponses) GetMangaCharactersWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetMangaCharactersResponse, error) {
	rsp, err := c.GetMangaCharacters(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMangaCharactersResponse(rsp)
}

// GetMangaExternalWithResponse request returning *GetMangaExternalResponse
func (c *ClientWithResponses) GetMangaExternalWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetMangaExternalResponse, error) {
	rsp, err := c.GetMangaExternal(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMangaExternalResponse(rsp)
}

// GetMangaTopicsWithResponse request returning *GetMangaTopicsResponse
func (c *ClientWithResponses) GetMangaTopicsWithResponse(ctx context.Context, id int, params *GetMangaTopicsParams, reqEditors ...RequestEditorFn) (*GetMangaTopicsResponse, error) {
	rsp, err := c.GetMangaTopics(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMangaTopicsResponse(rsp)
}

// GetMangaFullByIdWithResponse request returning *GetMangaFullByIdResponse
func (c *ClientWithResponses) GetMangaFullByIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetMangaFullByIdResponse, error) {
	rsp, err := c.GetMangaFullById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMangaFullByIdResponse(rsp)
}

// GetMangaMoreInfoWithResponse request returning *GetMangaMoreInfoResponse
func (c *ClientWithResponses) GetMangaMoreInfoWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetMangaMoreInfoResponse, error) {
	rsp, err := c.GetMangaMoreInfo(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMangaMoreInfoResponse(rsp)
}

// GetMangaNewsWithResponse request returning *GetMangaNewsResponse
func (c *ClientWithResponses) GetMangaNewsWithResponse(ctx context.Context, id int, params *GetMangaNewsParams, reqEditors ...RequestEditorFn) (*GetMangaNewsResponse, error) {
	rsp, err := c.GetMangaNews(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMangaNewsResponse(rsp)
}

// GetMangaPicturesWithResponse request returning *GetMangaPicturesResponse
func (c *ClientWithResponses) GetMangaPicturesWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetMangaPicturesResponse, error) {
	rsp, err := c.GetMangaPictures(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMangaPicturesResponse(rsp)
}

// GetMangaRecommendationsWithResponse request returning *GetMangaRecommendationsResponse
func (c *ClientWithResponses) GetMangaRecommendationsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetMangaRecommendationsResponse, error) {
	rsp, err := c.GetMangaRecommendations(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMangaRecommendationsResponse(rsp)
}

// GetMangaRelationsWithResponse request returning *GetMangaRelationsResponse
func (c *ClientWithResponses) GetMangaRelationsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetMangaRelationsResponse, error) {
	rsp, err := c.GetMangaRelations(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMangaRelationsResponse(rsp)
}

// GetMangaReviewsWithResponse request returning *GetMangaReviewsResponse
func (c *ClientWithResponses) GetMangaReviewsWithResponse(ctx context.Context, id int, params *GetMangaReviewsParams, reqEditors ...RequestEditorFn) (*GetMangaReviewsResponse, error) {
	rsp, err := c.GetMangaReviews(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMangaReviewsResponse(rsp)
}

// GetMangaStatisticsWithResponse request returning *GetMangaStatisticsResponse
func (c *ClientWithResponses) GetMangaStatisticsWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetMangaStatisticsResponse, error) {
	rsp, err := c.GetMangaStatistics(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMangaStatisticsResponse(rsp)
}

// GetMangaUserUpdatesWithResponse request returning *GetMangaUserUpdatesResponse
func (c *ClientWithResponses) GetMangaUserUpdatesWithResponse(ctx context.Context, id int, params *GetMangaUserUpdatesParams, reqEditors ...RequestEditorFn) (*GetMangaUserUpdatesResponse, error) {
	rsp, err := c.GetMangaUserUpdates(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMangaUserUpdatesResponse(rsp)
}

// GetPeopleSearchWithResponse request returning *GetPeopleSearchResponse
func (c *ClientWithResponses) GetPeopleSearchWithResponse(ctx context.Context, params *GetPeopleSearchParams, reqEditors ...RequestEditorFn) (*GetPeopleSearchResponse, error) {
	rsp, err := c.GetPeopleSearch(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPeopleSearchResponse(rsp)
}

// GetPersonByIdWithResponse request returning *GetPersonByIdResponse
func (c *ClientWithResponses) GetPersonByIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetPersonByIdResponse, error) {
	rsp, err := c.GetPersonById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersonByIdResponse(rsp)
}

// GetPersonAnimeWithResponse request returning *GetPersonAnimeResponse
func (c *ClientWithResponses) GetPersonAnimeWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetPersonAnimeResponse, error) {
	rsp, err := c.GetPersonAnime(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersonAnimeResponse(rsp)
}

// GetPersonFullByIdWithResponse request returning *GetPersonFullByIdResponse
func (c *ClientWithResponses) GetPersonFullByIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetPersonFullByIdResponse, error) {
	rsp, err := c.GetPersonFullById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersonFullByIdResponse(rsp)
}

// GetPersonMangaWithResponse request returning *GetPersonMangaResponse
func (c *ClientWithResponses) GetPersonMangaWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetPersonMangaResponse, error) {
	rsp, err := c.GetPersonManga(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersonMangaResponse(rsp)
}

// GetPersonPicturesWithResponse request returning *GetPersonPicturesResponse
func (c *ClientWithResponses) GetPersonPicturesWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetPersonPicturesResponse, error) {
	rsp, err := c.GetPersonPictures(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersonPicturesResponse(rsp)
}

// GetPersonVoicesWithResponse request returning *GetPersonVoicesResponse
func (c *ClientWithResponses) GetPersonVoicesWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetPersonVoicesResponse, error) {
	rsp, err := c.GetPersonVoices(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPersonVoicesResponse(rsp)
}

// GetProducersWithResponse request returning *GetProducersResponse
func (c *ClientWithResponses) GetProducersWithResponse(ctx context.Context, params *GetProducersParams, reqEditors ...RequestEditorFn) (*GetProducersResponse, error) {
	rsp, err := c.GetProducers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProducersResponse(rsp)
}

// GetProducerByIdWithResponse request returning *GetProducerByIdResponse
func (c *ClientWithResponses) GetProducerByIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetProducerByIdResponse, error) {
	rsp, err := c.GetProducerById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProducerByIdResponse(rsp)
}

// GetProducerExternalWithResponse request returning *GetProducerExternalResponse
func (c *ClientWithResponses) GetProducerExternalWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetProducerExternalResponse, error) {
	rsp, err := c.GetProducerExternal(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProducerExternalResponse(rsp)
}

// GetProducerFullByIdWithResponse request returning *GetProducerFullByIdResponse
func (c *ClientWithResponses) GetProducerFullByIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetProducerFullByIdResponse, error) {
	rsp, err := c.GetProducerFullById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProducerFullByIdResponse(rsp)
}

// GetRandomAnimeWithResponse request returning *GetRandomAnimeResponse
func (c *ClientWithResponses) GetRandomAnimeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRandomAnimeResponse, error) {
	rsp, err := c.GetRandomAnime(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRandomAnimeResponse(rsp)
}

// GetRandomCharactersWithResponse request returning *GetRandomCharactersResponse
func (c *ClientWithResponses) GetRandomCharactersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRandomCharactersResponse, error) {
	rsp, err := c.GetRandomCharacters(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRandomCharactersResponse(rsp)
}

// GetRandomMangaWithResponse request returning *GetRandomMangaResponse
func (c *ClientWithResponses) GetRandomMangaWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRandomMangaResponse, error) {
	rsp, err := c.GetRandomManga(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRandomMangaResponse(rsp)
}

// GetRandomPeopleWithResponse request returning *GetRandomPeopleResponse
func (c *ClientWithResponses) GetRandomPeopleWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRandomPeopleResponse, error) {
	rsp, err := c.GetRandomPeople(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRandomPeopleResponse(rsp)
}

// GetRandomUsersWithResponse request returning *GetRandomUsersResponse
func (c *ClientWithResponses) GetRandomUsersWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRandomUsersResponse, error) {
	rsp, err := c.GetRandomUsers(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRandomUsersResponse(rsp)
}

// GetRecentAnimeRecommendationsWithResponse request returning *GetRecentAnimeRecommendationsResponse
func (c *ClientWithResponses) GetRecentAnimeRecommendationsWithResponse(ctx context.Context, params *GetRecentAnimeRecommendationsParams, reqEditors ...RequestEditorFn) (*GetRecentAnimeRecommendationsResponse, error) {
	rsp, err := c.GetRecentAnimeRecommendations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecentAnimeRecommendationsResponse(rsp)
}

// GetRecentMangaRecommendationsWithResponse request returning *GetRecentMangaRecommendationsResponse
func (c *ClientWithResponses) GetRecentMangaRecommendationsWithResponse(ctx context.Context, params *GetRecentMangaRecommendationsParams, reqEditors ...RequestEditorFn) (*GetRecentMangaRecommendationsResponse, error) {
	rsp, err := c.GetRecentMangaRecommendations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecentMangaRecommendationsResponse(rsp)
}

// GetRecentAnimeReviewsWithResponse request returning *GetRecentAnimeReviewsResponse
func (c *ClientWithResponses) GetRecentAnimeReviewsWithResponse(ctx context.Context, params *GetRecentAnimeReviewsParams, reqEditors ...RequestEditorFn) (*GetRecentAnimeReviewsResponse, error) {
	rsp, err := c.GetRecentAnimeReviews(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecentAnimeReviewsResponse(rsp)
}

// GetRecentMangaReviewsWithResponse request returning *GetRecentMangaReviewsResponse
func (c *ClientWithResponses) GetRecentMangaReviewsWithResponse(ctx context.Context, params *GetRecentMangaReviewsParams, reqEditors ...RequestEditorFn) (*GetRecentMangaReviewsResponse, error) {
	rsp, err := c.GetRecentMangaReviews(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRecentMangaReviewsResponse(rsp)
}

// GetSchedulesWithResponse request returning *GetSchedulesResponse
func (c *ClientWithResponses) GetSchedulesWithResponse(ctx context.Context, params *GetSchedulesParams, reqEditors ...RequestEditorFn) (*GetSchedulesResponse, error) {
	rsp, err := c.GetSchedules(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSchedulesResponse(rsp)
}

// GetSeasonsListWithResponse request returning *GetSeasonsListResponse
func (c *ClientWithResponses) GetSeasonsListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSeasonsListResponse, error) {
	rsp, err := c.GetSeasonsList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSeasonsListResponse(rsp)
}

// GetSeasonNowWithResponse request returning *GetSeasonNowResponse
func (c *ClientWithResponses) GetSeasonNowWithResponse(ctx context.Context, params *GetSeasonNowParams, reqEditors ...RequestEditorFn) (*GetSeasonNowResponse, error) {
	rsp, err := c.GetSeasonNow(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSeasonNowResponse(rsp)
}

// GetSeasonUpcomingWithResponse request returning *GetSeasonUpcomingResponse
func (c *ClientWithResponses) GetSeasonUpcomingWithResponse(ctx context.Context, params *GetSeasonUpcomingParams, reqEditors ...RequestEditorFn) (*GetSeasonUpcomingResponse, error) {
	rsp, err := c.GetSeasonUpcoming(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSeasonUpcomingResponse(rsp)
}

// GetSeasonWithResponse request returning *GetSeasonResponse
func (c *ClientWithResponses) GetSeasonWithResponse(ctx context.Context, year int, season string, params *GetSeasonParams, reqEditors ...RequestEditorFn) (*GetSeasonResponse, error) {
	rsp, err := c.GetSeason(ctx, year, season, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSeasonResponse(rsp)
}

// GetTopAnimeWithResponse request returning *GetTopAnimeResponse
func (c *ClientWithResponses) GetTopAnimeWithResponse(ctx context.Context, params *GetTopAnimeParams, reqEditors ...RequestEditorFn) (*GetTopAnimeResponse, error) {
	rsp, err := c.GetTopAnime(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTopAnimeResponse(rsp)
}

// GetTopCharactersWithResponse request returning *GetTopCharactersResponse
func (c *ClientWithResponses) GetTopCharactersWithResponse(ctx context.Context, params *GetTopCharactersParams, reqEditors ...RequestEditorFn) (*GetTopCharactersResponse, error) {
	rsp, err := c.GetTopCharacters(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTopCharactersResponse(rsp)
}

// GetTopMangaWithResponse request returning *GetTopMangaResponse
func (c *ClientWithResponses) GetTopMangaWithResponse(ctx context.Context, params *GetTopMangaParams, reqEditors ...RequestEditorFn) (*GetTopMangaResponse, error) {
	rsp, err := c.GetTopManga(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTopMangaResponse(rsp)
}

// GetTopPeopleWithResponse request returning *GetTopPeopleResponse
func (c *ClientWithResponses) GetTopPeopleWithResponse(ctx context.Context, params *GetTopPeopleParams, reqEditors ...RequestEditorFn) (*GetTopPeopleResponse, error) {
	rsp, err := c.GetTopPeople(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTopPeopleResponse(rsp)
}

// GetTopReviewsWithResponse request returning *GetTopReviewsResponse
func (c *ClientWithResponses) GetTopReviewsWithResponse(ctx context.Context, params *GetTopReviewsParams, reqEditors ...RequestEditorFn) (*GetTopReviewsResponse, error) {
	rsp, err := c.GetTopReviews(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTopReviewsResponse(rsp)
}

// GetUsersSearchWithResponse request returning *GetUsersSearchResponse
func (c *ClientWithResponses) GetUsersSearchWithResponse(ctx context.Context, params *GetUsersSearchParams, reqEditors ...RequestEditorFn) (*GetUsersSearchResponse, error) {
	rsp, err := c.GetUsersSearch(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersSearchResponse(rsp)
}

// GetUserByIdWithResponse request returning *GetUserByIdResponse
func (c *ClientWithResponses) GetUserByIdWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetUserByIdResponse, error) {
	rsp, err := c.GetUserById(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserByIdResponse(rsp)
}

// GetUserProfileWithResponse request returning *GetUserProfileResponse
func (c *ClientWithResponses) GetUserProfileWithResponse(ctx context.Context, username string, reqEditors ...RequestEditorFn) (*GetUserProfileResponse, error) {
	rsp, err := c.GetUserProfile(ctx, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserProfileResponse(rsp)
}

// GetUserAboutWithResponse request returning *GetUserAboutResponse
func (c *ClientWithResponses) GetUserAboutWithResponse(ctx context.Context, username string, reqEditors ...RequestEditorFn) (*GetUserAboutResponse, error) {
	rsp, err := c.GetUserAbout(ctx, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserAboutResponse(rsp)
}

// GetUserAnimelistWithResponse request returning *GetUserAnimelistResponse
func (c *ClientWithResponses) GetUserAnimelistWithResponse(ctx context.Context, username string, params *GetUserAnimelistParams, reqEditors ...RequestEditorFn) (*GetUserAnimelistResponse, error) {
	rsp, err := c.GetUserAnimelist(ctx, username, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserAnimelistResponse(rsp)
}

// GetUserClubsWithResponse request returning *GetUserClubsResponse
func (c *ClientWithResponses) GetUserClubsWithResponse(ctx context.Context, username string, params *GetUserClubsParams, reqEditors ...RequestEditorFn) (*GetUserClubsResponse, error) {
	rsp, err := c.GetUserClubs(ctx, username, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserClubsResponse(rsp)
}

// GetUserExternalWithResponse request returning *GetUserExternalResponse
func (c *ClientWithResponses) GetUserExternalWithResponse(ctx context.Context, username string, reqEditors ...RequestEditorFn) (*GetUserExternalResponse, error) {
	rsp, err := c.GetUserExternal(ctx, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserExternalResponse(rsp)
}

// GetUserFavoritesWithResponse request returning *GetUserFavoritesResponse
func (c *ClientWithResponses) GetUserFavoritesWithResponse(ctx context.Context, username string, reqEditors ...RequestEditorFn) (*GetUserFavoritesResponse, error) {
	rsp, err := c.GetUserFavorites(ctx, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserFavoritesResponse(rsp)
}

// GetUserFriendsWithResponse request returning *GetUserFriendsResponse
func (c *ClientWithResponses) GetUserFriendsWithResponse(ctx context.Context, username string, params *GetUserFriendsParams, reqEditors ...RequestEditorFn) (*GetUserFriendsResponse, error) {
	rsp, err := c.GetUserFriends(ctx, username, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserFriendsResponse(rsp)
}

// GetUserFullProfileWithResponse request returning *GetUserFullProfileResponse
func (c *ClientWithResponses) GetUserFullProfileWithResponse(ctx context.Context, username string, reqEditors ...RequestEditorFn) (*GetUserFullProfileResponse, error) {
	rsp, err := c.GetUserFullProfile(ctx, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserFullProfileResponse(rsp)
}

// GetUserHistoryWithResponse request returning *GetUserHistoryResponse
func (c *ClientWithResponses) GetUserHistoryWithResponse(ctx context.Context, username string, params *GetUserHistoryParams, reqEditors ...RequestEditorFn) (*GetUserHistoryResponse, error) {
	rsp, err := c.GetUserHistory(ctx, username, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserHistoryResponse(rsp)
}

// GetUserMangaListWithResponse request returning *GetUserMangaListResponse
func (c *ClientWithResponses) GetUserMangaListWithResponse(ctx context.Context, username string, params *GetUserMangaListParams, reqEditors ...RequestEditorFn) (*GetUserMangaListResponse, error) {
	rsp, err := c.GetUserMangaList(ctx, username, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserMangaListResponse(rsp)
}

// GetUserRecommendationsWithResponse request returning *GetUserRecommendationsResponse
func (c *ClientWithResponses) GetUserRecommendationsWithResponse(ctx context.Context, username string, params *GetUserRecommendationsParams, reqEditors ...RequestEditorFn) (*GetUserRecommendationsResponse, error) {
	rsp, err := c.GetUserRecommendations(ctx, username, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserRecommendationsResponse(rsp)
}

// GetUserReviewsWithResponse request returning *GetUserReviewsResponse
func (c *ClientWithResponses) GetUserReviewsWithResponse(ctx context.Context, username string, params *GetUserReviewsParams, reqEditors ...RequestEditorFn) (*GetUserReviewsResponse, error) {
	rsp, err := c.GetUserReviews(ctx, username, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserReviewsResponse(rsp)
}

// GetUserStatisticsWithResponse request returning *GetUserStatisticsResponse
func (c *ClientWithResponses) GetUserStatisticsWithResponse(ctx context.Context, username string, reqEditors ...RequestEditorFn) (*GetUserStatisticsResponse, error) {
	rsp, err := c.GetUserStatistics(ctx, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserStatisticsResponse(rsp)
}

// GetUserUpdatesWithResponse request returning *GetUserUpdatesResponse
func (c *ClientWithResponses) GetUserUpdatesWithResponse(ctx context.Context, username string, reqEditors ...RequestEditorFn) (*GetUserUpdatesResponse, error) {
	rsp, err := c.GetUserUpdates(ctx, username, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserUpdatesResponse(rsp)
}

// GetWatchRecentEpisodesWithResponse request returning *GetWatchRecentEpisodesResponse
func (c *ClientWithResponses) GetWatchRecentEpisodesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWatchRecentEpisodesResponse, error) {
	rsp, err := c.GetWatchRecentEpisodes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWatchRecentEpisodesResponse(rsp)
}

// GetWatchPopularEpisodesWithResponse request returning *GetWatchPopularEpisodesResponse
func (c *ClientWithResponses) GetWatchPopularEpisodesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWatchPopularEpisodesResponse, error) {
	rsp, err := c.GetWatchPopularEpisodes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWatchPopularEpisodesResponse(rsp)
}

// GetWatchRecentPromosWithResponse request returning *GetWatchRecentPromosResponse
func (c *ClientWithResponses) GetWatchRecentPromosWithResponse(ctx context.Context, params *GetWatchRecentPromosParams, reqEditors ...RequestEditorFn) (*GetWatchRecentPromosResponse, error) {
	rsp, err := c.GetWatchRecentPromos(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWatchRecentPromosResponse(rsp)
}

// GetWatchPopularPromosWithResponse request returning *GetWatchPopularPromosResponse
func (c *ClientWithResponses) GetWatchPopularPromosWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetWatchPopularPromosResponse, error) {
	rsp, err := c.GetWatchPopularPromos(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWatchPopularPromosResponse(rsp)
}

// ParseGetAnimeSearchResponse parses an HTTP response from a GetAnimeSearchWithResponse call
func ParseGetAnimeSearchResponse(rsp *http.Response) (*GetAnimeSearchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnimeSearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AnimeSearch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAnimeByIdResponse parses an HTTP response from a GetAnimeByIdWithResponse call
func ParseGetAnimeByIdResponse(rsp *http.Response) (*GetAnimeByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnimeByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Anime Resource
			Data *Anime `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAnimeCharactersResponse parses an HTTP response from a GetAnimeCharactersWithResponse call
func ParseGetAnimeCharactersResponse(rsp *http.Response) (*GetAnimeCharactersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnimeCharactersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AnimeCharacters
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAnimeEpisodesResponse parses an HTTP response from a GetAnimeEpisodesWithResponse call
func ParseGetAnimeEpisodesResponse(rsp *http.Response) (*GetAnimeEpisodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnimeEpisodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AnimeEpisodes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAnimeEpisodeByIdResponse parses an HTTP response from a GetAnimeEpisodeByIdWithResponse call
func ParseGetAnimeEpisodeByIdResponse(rsp *http.Response) (*GetAnimeEpisodeByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnimeEpisodeByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Anime Episode Resource
			Data *AnimeEpisode `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAnimeExternalResponse parses an HTTP response from a GetAnimeExternalWithResponse call
func ParseGetAnimeExternalResponse(rsp *http.Response) (*GetAnimeExternalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnimeExternalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExternalLinks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAnimeForumResponse parses an HTTP response from a GetAnimeForumWithResponse call
func ParseGetAnimeForumResponse(rsp *http.Response) (*GetAnimeForumResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnimeForumResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Forum
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAnimeFullByIdResponse parses an HTTP response from a GetAnimeFullByIdWithResponse call
func ParseGetAnimeFullByIdResponse(rsp *http.Response) (*GetAnimeFullByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnimeFullByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Full anime Resource
			Data *AnimeFull `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAnimeMoreInfoResponse parses an HTTP response from a GetAnimeMoreInfoWithResponse call
func ParseGetAnimeMoreInfoResponse(rsp *http.Response) (*GetAnimeMoreInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnimeMoreInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Moreinfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAnimeNewsResponse parses an HTTP response from a GetAnimeNewsWithResponse call
func ParseGetAnimeNewsResponse(rsp *http.Response) (*GetAnimeNewsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnimeNewsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AnimeNews
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAnimePicturesResponse parses an HTTP response from a GetAnimePicturesWithResponse call
func ParseGetAnimePicturesResponse(rsp *http.Response) (*GetAnimePicturesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnimePicturesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PicturesVariants
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAnimeRecommendationsResponse parses an HTTP response from a GetAnimeRecommendationsWithResponse call
func ParseGetAnimeRecommendationsResponse(rsp *http.Response) (*GetAnimeRecommendationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnimeRecommendationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntryRecommendations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAnimeRelationsResponse parses an HTTP response from a GetAnimeRelationsWithResponse call
func ParseGetAnimeRelationsResponse(rsp *http.Response) (*GetAnimeRelationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnimeRelationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]Relation `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAnimeReviewsResponse parses an HTTP response from a GetAnimeReviewsWithResponse call
func ParseGetAnimeReviewsResponse(rsp *http.Response) (*GetAnimeReviewsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnimeReviewsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AnimeReviews
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAnimeStaffResponse parses an HTTP response from a GetAnimeStaffWithResponse call
func ParseGetAnimeStaffResponse(rsp *http.Response) (*GetAnimeStaffResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnimeStaffResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AnimeStaff
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAnimeStatisticsResponse parses an HTTP response from a GetAnimeStatisticsWithResponse call
func ParseGetAnimeStatisticsResponse(rsp *http.Response) (*GetAnimeStatisticsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnimeStatisticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AnimeStatistics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAnimeStreamingResponse parses an HTTP response from a GetAnimeStreamingWithResponse call
func ParseGetAnimeStreamingResponse(rsp *http.Response) (*GetAnimeStreamingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnimeStreamingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExternalLinks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAnimeThemesResponse parses an HTTP response from a GetAnimeThemesWithResponse call
func ParseGetAnimeThemesResponse(rsp *http.Response) (*GetAnimeThemesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnimeThemesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AnimeThemes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAnimeUserUpdatesResponse parses an HTTP response from a GetAnimeUserUpdatesWithResponse call
func ParseGetAnimeUserUpdatesResponse(rsp *http.Response) (*GetAnimeUserUpdatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnimeUserUpdatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AnimeUserupdates
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAnimeVideosResponse parses an HTTP response from a GetAnimeVideosWithResponse call
func ParseGetAnimeVideosResponse(rsp *http.Response) (*GetAnimeVideosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnimeVideosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AnimeVideos
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAnimeVideosEpisodesResponse parses an HTTP response from a GetAnimeVideosEpisodesWithResponse call
func ParseGetAnimeVideosEpisodesResponse(rsp *http.Response) (*GetAnimeVideosEpisodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnimeVideosEpisodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AnimeVideosEpisodes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCharactersSearchResponse parses an HTTP response from a GetCharactersSearchWithResponse call
func ParseGetCharactersSearchResponse(rsp *http.Response) (*GetCharactersSearchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCharactersSearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CharactersSearch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCharacterByIdResponse parses an HTTP response from a GetCharacterByIdWithResponse call
func ParseGetCharacterByIdResponse(rsp *http.Response) (*GetCharacterByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCharacterByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Character Resource
			Data *Character `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCharacterAnimeResponse parses an HTTP response from a GetCharacterAnimeWithResponse call
func ParseGetCharacterAnimeResponse(rsp *http.Response) (*GetCharacterAnimeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCharacterAnimeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CharacterAnime
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCharacterFullByIdResponse parses an HTTP response from a GetCharacterFullByIdWithResponse call
func ParseGetCharacterFullByIdResponse(rsp *http.Response) (*GetCharacterFullByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCharacterFullByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Character Resource
			Data *CharacterFull `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCharacterMangaResponse parses an HTTP response from a GetCharacterMangaWithResponse call
func ParseGetCharacterMangaResponse(rsp *http.Response) (*GetCharacterMangaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCharacterMangaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CharacterManga
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCharacterPicturesResponse parses an HTTP response from a GetCharacterPicturesWithResponse call
func ParseGetCharacterPicturesResponse(rsp *http.Response) (*GetCharacterPicturesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCharacterPicturesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CharacterPictures
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCharacterVoiceActorsResponse parses an HTTP response from a GetCharacterVoiceActorsWithResponse call
func ParseGetCharacterVoiceActorsResponse(rsp *http.Response) (*GetCharacterVoiceActorsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCharacterVoiceActorsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CharacterVoiceActors
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetClubsSearchResponse parses an HTTP response from a GetClubsSearchWithResponse call
func ParseGetClubsSearchResponse(rsp *http.Response) (*GetClubsSearchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClubsSearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClubsSearch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetClubsByIdResponse parses an HTTP response from a GetClubsByIdWithResponse call
func ParseGetClubsByIdResponse(rsp *http.Response) (*GetClubsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClubsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Club Resource
			Data *Club `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetClubMembersResponse parses an HTTP response from a GetClubMembersWithResponse call
func ParseGetClubMembersResponse(rsp *http.Response) (*GetClubMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClubMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				Images *UserImages `json:"images,omitempty"`

				// Url User URL
				Url *string `json:"url,omitempty"`

				// Username User's username
				Username *string `json:"username,omitempty"`
			} `json:"data,omitempty"`
			Pagination *struct {
				HasNextPage     *bool `json:"has_next_page,omitempty"`
				LastVisiblePage *int  `json:"last_visible_page,omitempty"`
			} `json:"pagination,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetClubRelationsResponse parses an HTTP response from a GetClubRelationsWithResponse call
func ParseGetClubRelationsResponse(rsp *http.Response) (*GetClubRelationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClubRelationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClubRelations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetClubStaffResponse parses an HTTP response from a GetClubStaffWithResponse call
func ParseGetClubStaffResponse(rsp *http.Response) (*GetClubStaffResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClubStaffResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ClubStaff
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAnimeGenresResponse parses an HTTP response from a GetAnimeGenresWithResponse call
func ParseGetAnimeGenresResponse(rsp *http.Response) (*GetAnimeGenresResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAnimeGenresResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Genres
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMangaGenresResponse parses an HTTP response from a GetMangaGenresWithResponse call
func ParseGetMangaGenresResponse(rsp *http.Response) (*GetMangaGenresResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMangaGenresResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Genres
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMagazinesResponse parses an HTTP response from a GetMagazinesWithResponse call
func ParseGetMagazinesResponse(rsp *http.Response) (*GetMagazinesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMagazinesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Magazines
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMangaSearchResponse parses an HTTP response from a GetMangaSearchWithResponse call
func ParseGetMangaSearchResponse(rsp *http.Response) (*GetMangaSearchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMangaSearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MangaSearch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMangaByIdResponse parses an HTTP response from a GetMangaByIdWithResponse call
func ParseGetMangaByIdResponse(rsp *http.Response) (*GetMangaByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMangaByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Manga Resource
			Data *Manga `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMangaCharactersResponse parses an HTTP response from a GetMangaCharactersWithResponse call
func ParseGetMangaCharactersResponse(rsp *http.Response) (*GetMangaCharactersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMangaCharactersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MangaCharacters
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMangaExternalResponse parses an HTTP response from a GetMangaExternalWithResponse call
func ParseGetMangaExternalResponse(rsp *http.Response) (*GetMangaExternalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMangaExternalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExternalLinks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMangaTopicsResponse parses an HTTP response from a GetMangaTopicsWithResponse call
func ParseGetMangaTopicsResponse(rsp *http.Response) (*GetMangaTopicsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMangaTopicsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Forum
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMangaFullByIdResponse parses an HTTP response from a GetMangaFullByIdWithResponse call
func ParseGetMangaFullByIdResponse(rsp *http.Response) (*GetMangaFullByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMangaFullByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Manga Resource
			Data *MangaFull `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMangaMoreInfoResponse parses an HTTP response from a GetMangaMoreInfoWithResponse call
func ParseGetMangaMoreInfoResponse(rsp *http.Response) (*GetMangaMoreInfoResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMangaMoreInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Moreinfo
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMangaNewsResponse parses an HTTP response from a GetMangaNewsWithResponse call
func ParseGetMangaNewsResponse(rsp *http.Response) (*GetMangaNewsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMangaNewsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MangaNews
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMangaPicturesResponse parses an HTTP response from a GetMangaPicturesWithResponse call
func ParseGetMangaPicturesResponse(rsp *http.Response) (*GetMangaPicturesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMangaPicturesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MangaPictures
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMangaRecommendationsResponse parses an HTTP response from a GetMangaRecommendationsWithResponse call
func ParseGetMangaRecommendationsResponse(rsp *http.Response) (*GetMangaRecommendationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMangaRecommendationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest EntryRecommendations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMangaRelationsResponse parses an HTTP response from a GetMangaRelationsWithResponse call
func ParseGetMangaRelationsResponse(rsp *http.Response) (*GetMangaRelationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMangaRelationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]Relation `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMangaReviewsResponse parses an HTTP response from a GetMangaReviewsWithResponse call
func ParseGetMangaReviewsResponse(rsp *http.Response) (*GetMangaReviewsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMangaReviewsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MangaReviews
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMangaStatisticsResponse parses an HTTP response from a GetMangaStatisticsWithResponse call
func ParseGetMangaStatisticsResponse(rsp *http.Response) (*GetMangaStatisticsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMangaStatisticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MangaStatistics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMangaUserUpdatesResponse parses an HTTP response from a GetMangaUserUpdatesWithResponse call
func ParseGetMangaUserUpdatesResponse(rsp *http.Response) (*GetMangaUserUpdatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMangaUserUpdatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MangaUserupdates
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPeopleSearchResponse parses an HTTP response from a GetPeopleSearchWithResponse call
func ParseGetPeopleSearchResponse(rsp *http.Response) (*GetPeopleSearchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPeopleSearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PeopleSearch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPersonByIdResponse parses an HTTP response from a GetPersonByIdWithResponse call
func ParseGetPersonByIdResponse(rsp *http.Response) (*GetPersonByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersonByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Person Resource
			Data *Person `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPersonAnimeResponse parses an HTTP response from a GetPersonAnimeWithResponse call
func ParseGetPersonAnimeResponse(rsp *http.Response) (*GetPersonAnimeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersonAnimeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PersonAnime
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPersonFullByIdResponse parses an HTTP response from a GetPersonFullByIdWithResponse call
func ParseGetPersonFullByIdResponse(rsp *http.Response) (*GetPersonFullByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersonFullByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Person Resource
			Data *PersonFull `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPersonMangaResponse parses an HTTP response from a GetPersonMangaWithResponse call
func ParseGetPersonMangaResponse(rsp *http.Response) (*GetPersonMangaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersonMangaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PersonManga
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPersonPicturesResponse parses an HTTP response from a GetPersonPicturesWithResponse call
func ParseGetPersonPicturesResponse(rsp *http.Response) (*GetPersonPicturesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersonPicturesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PersonPictures
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPersonVoicesResponse parses an HTTP response from a GetPersonVoicesWithResponse call
func ParseGetPersonVoicesResponse(rsp *http.Response) (*GetPersonVoicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPersonVoicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PersonVoiceActingRoles
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetProducersResponse parses an HTTP response from a GetProducersWithResponse call
func ParseGetProducersResponse(rsp *http.Response) (*GetProducersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProducersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Producers
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetProducerByIdResponse parses an HTTP response from a GetProducerByIdWithResponse call
func ParseGetProducerByIdResponse(rsp *http.Response) (*GetProducerByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProducerByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Producers Resource
			Data *Producer `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetProducerExternalResponse parses an HTTP response from a GetProducerExternalWithResponse call
func ParseGetProducerExternalResponse(rsp *http.Response) (*GetProducerExternalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProducerExternalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExternalLinks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetProducerFullByIdResponse parses an HTTP response from a GetProducerFullByIdWithResponse call
func ParseGetProducerFullByIdResponse(rsp *http.Response) (*GetProducerFullByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProducerFullByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Producers Resource
			Data *ProducerFull `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRandomAnimeResponse parses an HTTP response from a GetRandomAnimeWithResponse call
func ParseGetRandomAnimeResponse(rsp *http.Response) (*GetRandomAnimeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRandomAnimeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Anime Resource
			Data *Anime `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRandomCharactersResponse parses an HTTP response from a GetRandomCharactersWithResponse call
func ParseGetRandomCharactersResponse(rsp *http.Response) (*GetRandomCharactersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRandomCharactersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Character Resource
			Data *Character `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRandomMangaResponse parses an HTTP response from a GetRandomMangaWithResponse call
func ParseGetRandomMangaResponse(rsp *http.Response) (*GetRandomMangaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRandomMangaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Manga Resource
			Data *Manga `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRandomPeopleResponse parses an HTTP response from a GetRandomPeopleWithResponse call
func ParseGetRandomPeopleResponse(rsp *http.Response) (*GetRandomPeopleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRandomPeopleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Person Resource
			Data *Person `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRandomUsersResponse parses an HTTP response from a GetRandomUsersWithResponse call
func ParseGetRandomUsersResponse(rsp *http.Response) (*GetRandomUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRandomUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *UserProfile `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRecentAnimeRecommendationsResponse parses an HTTP response from a GetRecentAnimeRecommendationsWithResponse call
func ParseGetRecentAnimeRecommendationsResponse(rsp *http.Response) (*GetRecentAnimeRecommendationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecentAnimeRecommendationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Recommendations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRecentMangaRecommendationsResponse parses an HTTP response from a GetRecentMangaRecommendationsWithResponse call
func ParseGetRecentMangaRecommendationsResponse(rsp *http.Response) (*GetRecentMangaRecommendationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecentMangaRecommendationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Recommendations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRecentAnimeReviewsResponse parses an HTTP response from a GetRecentAnimeReviewsWithResponse call
func ParseGetRecentAnimeReviewsResponse(rsp *http.Response) (*GetRecentAnimeReviewsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecentAnimeReviewsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetRecentMangaReviewsResponse parses an HTTP response from a GetRecentMangaReviewsWithResponse call
func ParseGetRecentMangaReviewsResponse(rsp *http.Response) (*GetRecentMangaReviewsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRecentMangaReviewsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSchedulesResponse parses an HTTP response from a GetSchedulesWithResponse call
func ParseGetSchedulesResponse(rsp *http.Response) (*GetSchedulesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSchedulesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Schedules
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSeasonsListResponse parses an HTTP response from a GetSeasonsListWithResponse call
func ParseGetSeasonsListResponse(rsp *http.Response) (*GetSeasonsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSeasonsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Seasons
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSeasonNowResponse parses an HTTP response from a GetSeasonNowWithResponse call
func ParseGetSeasonNowResponse(rsp *http.Response) (*GetSeasonNowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSeasonNowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AnimeSearch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSeasonUpcomingResponse parses an HTTP response from a GetSeasonUpcomingWithResponse call
func ParseGetSeasonUpcomingResponse(rsp *http.Response) (*GetSeasonUpcomingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSeasonUpcomingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AnimeSearch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSeasonResponse parses an HTTP response from a GetSeasonWithResponse call
func ParseGetSeasonResponse(rsp *http.Response) (*GetSeasonResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSeasonResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AnimeSearch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTopAnimeResponse parses an HTTP response from a GetTopAnimeWithResponse call
func ParseGetTopAnimeResponse(rsp *http.Response) (*GetTopAnimeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTopAnimeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AnimeSearch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTopCharactersResponse parses an HTTP response from a GetTopCharactersWithResponse call
func ParseGetTopCharactersResponse(rsp *http.Response) (*GetTopCharactersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTopCharactersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CharactersSearch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTopMangaResponse parses an HTTP response from a GetTopMangaWithResponse call
func ParseGetTopMangaResponse(rsp *http.Response) (*GetTopMangaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTopMangaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MangaSearch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTopPeopleResponse parses an HTTP response from a GetTopPeopleWithResponse call
func ParseGetTopPeopleResponse(rsp *http.Response) (*GetTopPeopleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTopPeopleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PeopleSearch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTopReviewsResponse parses an HTTP response from a GetTopReviewsWithResponse call
func ParseGetTopReviewsResponse(rsp *http.Response) (*GetTopReviewsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTopReviewsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Data       *[]GetTopReviews_200_Data_Data_Item `json:"data,omitempty"`
				Pagination *struct {
					HasNextPage     *bool `json:"has_next_page,omitempty"`
					LastVisiblePage *int  `json:"last_visible_page,omitempty"`
				} `json:"pagination,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUsersSearchResponse parses an HTTP response from a GetUsersSearchWithResponse call
func ParseGetUsersSearchResponse(rsp *http.Response) (*GetUsersSearchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersSearchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UsersSearch
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserByIdResponse parses an HTTP response from a GetUserByIdWithResponse call
func ParseGetUserByIdResponse(rsp *http.Response) (*GetUserByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data User Meta By ID
			Data *UserById `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserProfileResponse parses an HTTP response from a GetUserProfileWithResponse call
func ParseGetUserProfileResponse(rsp *http.Response) (*GetUserProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *UserProfile `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserAboutResponse parses an HTTP response from a GetUserAboutWithResponse call
func ParseGetUserAboutResponse(rsp *http.Response) (*GetUserAboutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserAboutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserAbout
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserAnimelistResponse parses an HTTP response from a GetUserAnimelistWithResponse call
func ParseGetUserAnimelistResponse(rsp *http.Response) (*GetUserAnimelistResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserAnimelistResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserClubsResponse parses an HTTP response from a GetUserClubsWithResponse call
func ParseGetUserClubsResponse(rsp *http.Response) (*GetUserClubsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserClubsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserClubs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserExternalResponse parses an HTTP response from a GetUserExternalWithResponse call
func ParseGetUserExternalResponse(rsp *http.Response) (*GetUserExternalResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserExternalResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExternalLinks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserFavoritesResponse parses an HTTP response from a GetUserFavoritesWithResponse call
func ParseGetUserFavoritesResponse(rsp *http.Response) (*GetUserFavoritesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserFavoritesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *UserFavorites `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserFriendsResponse parses an HTTP response from a GetUserFriendsWithResponse call
func ParseGetUserFriendsResponse(rsp *http.Response) (*GetUserFriendsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserFriendsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserFriends
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserFullProfileResponse parses an HTTP response from a GetUserFullProfileWithResponse call
func ParseGetUserFullProfileResponse(rsp *http.Response) (*GetUserFullProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserFullProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Data Transform the resource into an array.
			Data *UserProfileFull `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserHistoryResponse parses an HTTP response from a GetUserHistoryWithResponse call
func ParseGetUserHistoryResponse(rsp *http.Response) (*GetUserHistoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserHistory
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserMangaListResponse parses an HTTP response from a GetUserMangaListWithResponse call
func ParseGetUserMangaListResponse(rsp *http.Response) (*GetUserMangaListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserMangaListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserRecommendationsResponse parses an HTTP response from a GetUserRecommendationsWithResponse call
func ParseGetUserRecommendationsResponse(rsp *http.Response) (*GetUserRecommendationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserRecommendationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Recommendations
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserReviewsResponse parses an HTTP response from a GetUserReviewsWithResponse call
func ParseGetUserReviewsResponse(rsp *http.Response) (*GetUserReviewsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserReviewsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *struct {
				Data       *[]GetUserReviews_200_Data_Data_Item `json:"data,omitempty"`
				Pagination *struct {
					HasNextPage     *bool `json:"has_next_page,omitempty"`
					LastVisiblePage *int  `json:"last_visible_page,omitempty"`
				} `json:"pagination,omitempty"`
			} `json:"data,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserStatisticsResponse parses an HTTP response from a GetUserStatisticsWithResponse call
func ParseGetUserStatisticsResponse(rsp *http.Response) (*GetUserStatisticsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserStatisticsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserStatistics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserUpdatesResponse parses an HTTP response from a GetUserUpdatesWithResponse call
func ParseGetUserUpdatesResponse(rsp *http.Response) (*GetUserUpdatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserUpdatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserUpdates
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetWatchRecentEpisodesResponse parses an HTTP response from a GetWatchRecentEpisodesWithResponse call
func ParseGetWatchRecentEpisodesResponse(rsp *http.Response) (*GetWatchRecentEpisodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWatchRecentEpisodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WatchEpisodes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetWatchPopularEpisodesResponse parses an HTTP response from a GetWatchPopularEpisodesWithResponse call
func ParseGetWatchPopularEpisodesResponse(rsp *http.Response) (*GetWatchPopularEpisodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWatchPopularEpisodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WatchEpisodes
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetWatchRecentPromosResponse parses an HTTP response from a GetWatchRecentPromosWithResponse call
func ParseGetWatchRecentPromosResponse(rsp *http.Response) (*GetWatchRecentPromosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWatchRecentPromosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WatchPromos
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetWatchPopularPromosResponse parses an HTTP response from a GetWatchPopularPromosWithResponse call
func ParseGetWatchPopularPromosResponse(rsp *http.Response) (*GetWatchPopularPromosResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWatchPopularPromosResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WatchPromos
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
